<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-12-03 Sun 11:58 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Course on Homotopy Type Theory</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Mario Román" />
<meta name="description" content="Notes following the course on homotopy type theory by Robert Harper"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>
<p style="display:none"> \(\newcommand{\threepartdef}[6]{\left\{\begin{array}{lll} #1 & \mbox{if } #2 \\ #3 & \mbox{if } #4 \\ #5 & \mbox{if } #6 \end{array} \right.}\) </p>
<p style="display:none"> \(\newcommand{\twopartdef}[4]{\left\{\begin{array}{ll} #1 & \mbox{if } #2 \\ #3 & \mbox{if } #4 \end{array} \right.}\) </p>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Course on Homotopy Type Theory</h1>

<div id="outline-container-org4f0a1f7" class="outline-2">
<h2 id="org4f0a1f7"><span class="section-number-2">1</span> Lecture 1: Intuitionistic Type Theory</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-org8391f13" class="outline-3">
<h3 id="org8391f13"><span class="section-number-3">1.1</span> Intuitionistic Type Theory (TT),</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The <b>Intuitionistic Type Theory</b> is based on the work of Per
Martin-Löf on the 1970s.  It is an analysis and expansion of Brouwer's
intuitionism.
</p>
</div>
</div>

<div id="outline-container-org4458ca8" class="outline-3">
<h3 id="org4458ca8"><span class="section-number-3">1.2</span> Intensional Type Theory (ITT)</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The <b>Intensional Type Theory</b> will be our base theory. Other forms of
type theory are extensions of this one.
</p>
</div>
</div>

<div id="outline-container-org516e139" class="outline-3">
<h3 id="org516e139"><span class="section-number-3">1.3</span> Extensional Type Theory (ETT)</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The <b>Extensional Type Theory</b> has the core of ITT plus the principles
of equality reflection (ER) and uniqueness of the identity proofs
(UIP).
</p>

<p>
This is the intuitionistic theory of sets in which NuPRL is based.
It is a form of constructive set theory, developed by Bishop; where
types are treated as sets.
</p>
</div>
</div>

<div id="outline-container-org0fefaa1" class="outline-3">
<h3 id="org0fefaa1"><span class="section-number-3">1.4</span> Homotopy Type Theory (HoTT)</h3>
<div class="outline-text-3" id="text-1-4">
<p>
The <b>Homotopy Type Theory</b> is an elaboration of ITT with higher
inductive types (HIT) and the univalence axiom (UA).
</p>

<p>
It is an intuitionistic theory of weak \(\infty\text{-groupoids}\). Here types
are spaces in an abstract sense.
</p>
</div>
</div>
<div id="outline-container-org5a063f8" class="outline-3">
<h3 id="org5a063f8"><span class="section-number-3">1.5</span> Brower's program</h3>
<div class="outline-text-3" id="text-1-5">
<p>
The <b>Brower's program</b> is a philosophy of mathematics based on the
following ideas
</p>

<ol class="org-ol">
<li>mathematics is a human social activity. The focus is on the <i>language</i>
as a tool for communication of mathematical concepts.</li>

<li>the fundamental human capability is the understanding an execution
of <i>algorithms</i> for performing <i>constructions</i>. Proofs are forms
of construction.</li>
</ol>

<p>
In this setting, the only way to describe infinite things is by
communicate them with an algorithm. 
</p>
</div>

<div id="outline-container-orgd4f8f1d" class="outline-4">
<h4 id="orgd4f8f1d"><span class="section-number-4">1.5.1</span> Proof relevance</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
From the second point, arises the principle of <b>proof relevance</b>.
Proofs are mathematical objects that we can see an manipulate. In
other foundations of mathematics, only a limiting enumerable set of
formal proofs can be viewed as proofs.
</p>
</div>
</div>

<div id="outline-container-orgd5acab5" class="outline-4">
<h4 id="orgd5acab5"><span class="section-number-4">1.5.2</span> Proof relevance in HoTT</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
In HoTT, our proofs will be paths in a space. This conception
will provide a synthetic way of working with homotopy which is a
cleaner, shorter and mechanizable way writting proofs.
</p>
</div>
</div>

<div id="outline-container-org9bd14b4" class="outline-4">
<h4 id="org9bd14b4"><span class="section-number-4">1.5.3</span> Synthetic perspective in mechanized reasoning</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
Synthetic geometry is what Euclides did; analytic geometry is what
Descartes did. The traditional formulation of Homotopy Theory, using
euclidean spaces and topology, is an analytic one. Synthetic
formulations of Homotopy Theory are based on Quillen model categories or
HoTT.
</p>

<p>
This distinction of synthetic and analytical is due to Lawvere.
</p>

<p>
<i>Twelf vs Coq is another example</i>
</p>
</div>
</div>
</div>
<div id="outline-container-org8c23967" class="outline-3">
<h3 id="org8c23967"><span class="section-number-3">1.6</span> Type Theory</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Type theory is an analysis and codification of Brower's intuitionism
drawning on Gentzen's proof theory. Types classify the admisible
constructions. A type is defined by
</p>

<ul class="org-ul">
<li><b>introduction rules</b>, showing how to make a construction.</li>
<li><b>elimination rules</b>, showing how to use a construction.</li>
</ul>

<p>
linked by the <b>inversion principle</b>, or principle of conservation of
proofs; stating that the introduction is inverse to the elimination.
This inversion principle is the basis for the computational content
of our language.
</p>
</div>
</div>

<div id="outline-container-org0401268" class="outline-3">
<h3 id="org0401268"><span class="section-number-3">1.7</span> Axiomatic freedom of constructive mathematics</h3>
<div class="outline-text-3" id="text-1-7">
<p>
In the Hilbert/Brouwer debate, Hilbert believed that Brouwer was negating
everything that has been done so far; but, as fewer assumptions lead to
stronger results, the exclusion of certain principles leads only to axiomatic
freedom.
</p>

<p>
For example, the law of excluded middle is not negated on constructive
mathematics, they are simply independent of it; but it can still be
taken as an hypothesis on certain subfields.
</p>

<p>
We can now include certain assumptions locally, and so, the
constructivity is not a limitation.
</p>
</div>
</div>
<div id="outline-container-org79fb626" class="outline-3">
<h3 id="org79fb626"><span class="section-number-3">1.8</span> Computational aspect</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Type theory acts as an unified theory of computation. Programming
languages and computation are particular manifestations of this
unified theory.
</p>
</div>
</div>

<div id="outline-container-orga7ef553" class="outline-3">
<h3 id="orga7ef553"><span class="section-number-3">1.9</span> Computational trinitarianism</h3>
<div class="outline-text-3" id="text-1-9">
<p>
\[\begin{tikzcd}[row sep=huge, col sep=tiny]
& \begin{matrix}\text{Type}\\ \text{Theory}\end{matrix} \drar[to-to]\dlar[to-to] & \\
\text{Logic}\arrow[rr,to-to] & & \begin{matrix}\text{Category}\\ \text{Theory}\end{matrix}
\end{tikzcd}\]
</p>

<p>
There is a complete correspondence between the three theories.
</p>
</div>
</div>
<div id="outline-container-org9813c10" class="outline-3">
<h3 id="org9813c10"><span class="section-number-3">1.10</span> Intuitionistic logic</h3>
<div class="outline-text-3" id="text-1-10">
<p>
<b>Intuitionistic logic</b> is based on the principles of intuitionism.
It has the following judgements
</p>

<ol class="org-ol">
<li>\(A\) is a proposition.</li>
<li>\(A\) is a true proposition, it has a proof.</li>
</ol>

<p>
We do not expect that a proposition is either provable or refutable.
We assume also <i>open-endedness</i>, we cannot write all the proofs in a
systematic way.
</p>
</div>
</div>

<div id="outline-container-org46e7349" class="outline-3">
<h3 id="org46e7349"><span class="section-number-3">1.11</span> Negative fragment of intuitionistic propositional logic</h3>
<div class="outline-text-3" id="text-1-11">
<p>
We will write a grammar of proofs.
</p>

<ul class="org-ul">
<li><p>
The trivially true proposition, this is the <b>truth-formation</b>
rule
</p>

\begin{prooftree}
\RightLabel{(T-form)}
\AxiomC{}
\UnaryInfC{T prop}
\end{prooftree}

<p>
this trivially true proposition is true
</p>

\begin{prooftree}
\RightLabel{(T-intro)}
\AxiomC{}
\UnaryInfC{T true}
\end{prooftree}

<p>
but there is no truth elimination rule, as we are not using any
information when we write this proposition.
</p></li>

<li><p>
Conjunction formation
</p>

\begin{prooftree}
\RightLabel{($\wedge$-form)}
\AxiomC{A prop}
\AxiomC{B prop}
\BinaryInfC{A $\wedge$ B prop}
\end{prooftree}

<p>
conjunction introduction
</p>

\begin{prooftree}
\RightLabel{($\wedge$-intro)}
\AxiomC{A true}
\AxiomC{B true}
\BinaryInfC{A $\wedge$ B true}
\end{prooftree}

<p>
we will use two elimination rules to extract the two pieces 
of information that went into that fact.
</p>

\begin{prooftree}
\RightLabel{($\wedge$-elim$_1$)}
\AxiomC{A $\wedge$ B true}
\UnaryInfC{A true}
\RightLabel{($\wedge$-elim$_2$)}
\AxiomC{A $\wedge$ B true}
\UnaryInfC{B true}
\noLine
\BinaryInfC{}
\end{prooftree}</li>

<li><p>
Implication formation
</p>

\begin{prooftree}
\RightLabel{($\supset$-form)}
\AxiomC{A prop}
\AxiomC{B prop}
\BinaryInfC{A $\supset$ B prop}
\end{prooftree}

<p>
and implication introduction, which uses only entailment
</p>

\begin{prooftree}
\RightLabel{($\supset$-intro)}
\AxiomC{A true $\vdash$ B true}
\UnaryInfC{A $\supset$ B true}
\end{prooftree}

<p>
in the Hilbert formulations of logic, we supress the difference
between entailment and implication. The logical entailment is prior
to the implication, it is a map of proofs; while the implication only
captures that into the logic. The elimination rule is the modus ponens
</p>

\begin{prooftree}
\RightLabel{($\supset$-elim)}
\AxiomC{A $\supset$ B true}
\AxiomC{A true}
\BinaryInfC{B true}
\end{prooftree}</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1aeca4a" class="outline-2">
<h2 id="org1aeca4a"><span class="section-number-2">2</span> Lecture 2: Intuitionistic Propositional Logic</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orge72c876" class="outline-3">
<h3 id="orge72c876"><span class="section-number-3">2.1</span> Negative fragment of intuitionistic propositional logic</h3>
<div class="outline-text-3" id="text-2-1">
<p>
We have talked about
</p>

<ul class="org-ul">
<li>the Gentzen principle of conservation of evidence.</li>
<li>the truth value.</li>
<li>the conjunction.</li>
<li>the implication.</li>
</ul>

<p>
Why are these "correct" rules? We are keeping a correspondence between
introduction and elimination rules; that is the beauty of the Gentzen
system and what gives rise to the computational interpretation.
</p>

<p>
These are not arbitrary rules, there is a coherence that is being kept.
</p>
</div>
</div>
<div id="outline-container-orgd83dd41" class="outline-3">
<h3 id="orgd83dd41"><span class="section-number-3">2.2</span> Structural properties of entailment</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The concept of <b>logical entailment</b> is a compound judgement. It express
the idea of a conclusion derived from a set of assumptions
</p>

<p>
\[\underbrace{
A_1 \text{ true},
A_2 \text{ true},
\dots,
A_n \text{ true}}_{\Gamma}
\vdash
A
\]
</p>

<p>
Logical entailment is a mapping between propositions.
The properties of logical entailment (aka hypothetical judgement) are
the following properties
</p>

<ol class="org-ol">
<li>Reflexivity (R), \(A \text{ true} \vdash A \text{ true}\).</li>
<li><p>
Transitivity (T),
</p>

\begin{prooftree}
\RightLabel{(T)}
\AxiomC{$\Gamma_1 \vdash A$ true}
\AxiomC{$\Gamma_2,A$ true $\vdash B$ true}
\BinaryInfC{$\Gamma_1,\Gamma_{2} \vdash B$ true}
\end{prooftree}

<p>
in presence of the weakening, contraction, and exchange properties,
this can be rewritten using only a \(\Gamma\).
</p></li>

<li><p>
Weakening (W),
</p>

\begin{prooftree}
\RightLabel{(W)}
\AxiomC{$\Gamma$ $\vdash A$ true}
\UnaryInfC{$\Gamma,B$ true $\vdash A$ true}
\end{prooftree}

<p>
where the two first properties are fundamental, and this third is
not as fundamental. You can consider deniying this principle, and
you will arrive at the notion of <i>relevant entitlement</i>, where every
assumption has to be used in the entitlement.
</p></li>

<li><p>
Contraction (C), 
</p>

\begin{prooftree}
\RightLabel{(C)}
\AxiomC{$\Gamma,A$ true,$A$ true $\vdash B$ true}
\UnaryInfC{$\Gamma, A$ true $\vdash B$ true}
\end{prooftree}

<p>
in certain logics, we may will want to keep an accounting of
how many times have we used a lemma; we will have to deny this
property.
</p></li>

<li><p>
Exchange (E), the order of the assumptions does not matter
</p>

\begin{prooftree}
\RightLabel{(C)}
\AxiomC{$\Gamma \vdash A$ true}
\UnaryInfC{$\pi(\Gamma) \vdash A$ true}
\end{prooftree}

<p>
where \(\pi\) is any permutation.
</p></li>
</ol>

<p>
When any of these properties fail, we talk of substructural entailment.
</p>
</div>
</div>

<div id="outline-container-org176aac2" class="outline-3">
<h3 id="org176aac2"><span class="section-number-3">2.3</span> Local form</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We are writing the rules in local form. They can be used in the same
way on the presence of assumptions. A \(\Gamma\) could be added to all
the rules to obtain the global form. It is implied in our rules.
</p>

<p>
There are certain scenarios in which we will want \(\Gamma\) to be explicitely
empty.
</p>
</div>
</div>

<div id="outline-container-orgb9de08a" class="outline-3">
<h3 id="orgb9de08a"><span class="section-number-3">2.4</span> Order-theoretic formulation</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Let us define \(A \leq B\), an order on propositions, meaning that
\(A \text{ true} \vdash B \text{ true}\).
</p>
</div>

<div id="outline-container-org18de7d9" class="outline-4">
<h4 id="org18de7d9"><span class="section-number-4">2.4.1</span> Preorder</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
This is a preorder,
</p>

<ul class="org-ul">
<li><p>
it is reflexive,
</p>

\begin{prooftree}
\RightLabel{($\leq$-refl)}
\AxiomC{}
\UnaryInfC{$A \leq A$}
\end{prooftree}</li>
</ul>


<ul class="org-ul">
<li><p>
it is transitive,
</p>

\begin{prooftree}
\RightLabel{($\leq$-trans)}
\AxiomC{$A \leq B$}
\AxiomC{$B \leq C$}
\BinaryInfC{$A \leq C$}
\end{prooftree}</li>

<li><p>
we have a greatest, final element
</p>

\begin{prooftree}
\RightLabel{($\leq_\top$)}
\AxiomC{}
\UnaryInfC{$A \leq \top$}
\end{prooftree}</li>

<li><p>
we have meets given by conjunction. That is, there is a lower
bound
</p>

\begin{prooftree}
\RightLabel{($\leq,\wedge_1$)}
\AxiomC{}
\UnaryInfC{$A \wedge B \leq A$}
\RightLabel{($\leq,\wedge_2$)}
\AxiomC{}
\UnaryInfC{$A \wedge B \leq B$}
\noLine
\BinaryInfC{}
\end{prooftree}

<p>
which is also universal
</p>

\begin{prooftree}
\RightLabel{($\leq,\wedge$-bound)}
\AxiomC{$C \leq A$}
\AxiomC{$C \leq B$}
\BinaryInfC{$C \leq A \wedge B$}
\end{prooftree}</li>
</ul>

<p>
Those follow from the properties of entailment. We can draw those
properties with Hasse diagrams, where we can see a similarity with
a product diagram on category theory
</p>

<p>
\[\begin{tikzcd}[column sep=tiny]
& C \dar[dashed] \ar[ddr,bend left]\ar[ddl, bend right] & \\
& A \wedge B \drar\dlar & \\
A & & B &.
\end{tikzcd}\]
</p>
</div>
</div>

<div id="outline-container-org3d829ca" class="outline-4">
<h4 id="org3d829ca"><span class="section-number-4">2.4.2</span> Antisymmetry and equivalence</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
We have now a lower semilattice. Sometimes, lower semilattices are
defined to be partial orders, where we have antisymmetry
</p>

\begin{prooftree}
\RightLabel{}
\AxiomC{$A \leq B$}
\AxiomC{$B \leq A$}
\BinaryInfC{$A = B$}
\end{prooftree}

<p>
but we are going to work without antisymmetry. We haven't talked yet
about equality, but we are going to introduce the univalent principle.
We could define \(A \simeq B\) when \(A \leq B\) and \(B \leq A\), they are not equal,
but equivalent. We could also work with equivalence classes \([A]_{\simeq}\) here.
Univalence will imply the equality of equivalent propositions.
</p>
</div>
</div>
</div>

<div id="outline-container-org53d7b51" class="outline-3">
<h3 id="org53d7b51"><span class="section-number-3">2.5</span> Positive fragment of IPL</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Now we write the grammar of the positive fragment
</p>

<ul class="org-ul">
<li><p>
The false proposition, this is the <b>false-formation</b> rule
</p>

\begin{prooftree}
\RightLabel{($\bot$-form)}
\AxiomC{}
\UnaryInfC{$\bot$ prop}
\end{prooftree}

<p>
there is no introduction rule, only an elimination rule
</p>

\begin{prooftree}
\RightLabel{($\bot$-elim)}
\AxiomC{$\bot$ true}
\UnaryInfC{A true}
\end{prooftree}

<p>
since there is no introduction rule and this never happens,
this preserves the coherence principle.
</p></li>

<li><p>
Disjunction formation
</p>

\begin{prooftree}
\RightLabel{($\vee$-form)}
\AxiomC{A prop}
\AxiomC{B prop}
\BinaryInfC{A $\vee$ B prop}
\end{prooftree}

<p>
disjunction introduction
</p>

\begin{prooftree}
\RightLabel{($\vee$-intro$_{1}$)}
\AxiomC{A true}
\UnaryInfC{A $\vee$ B true}
\RightLabel{($\vee$-intro$_{2}$)}
\AxiomC{B true}
\UnaryInfC{A $\vee$ B true}
\noLine
\BinaryInfC{}
\end{prooftree}

<p>
we will use an elimination rule to extract the piece of
of information that went into that fact as in
</p>

\begin{prooftree}
\RightLabel{($\vee$-elim)}
\AxiomC{A $\vee$ B true}
\AxiomC{A true $\vdash$ C true}
\AxiomC{B true $\vdash$ C true}
\TrinaryInfC{C true}
\end{prooftree}</li>
</ul>
</div>
</div>

<div id="outline-container-org0644842" class="outline-3">
<h3 id="org0644842"><span class="section-number-3">2.6</span> Order-theoretical properties</h3>
<div class="outline-text-3" id="text-2-6">
<p>
We have now a least or initial element,
</p>

\begin{prooftree}
\RightLabel{($\leq$-$\bot$)}
\AxiomC{}
\UnaryInfC{$\bot \leq A$}
\end{prooftree}

<p>
and joins or upper bounds
</p>

\begin{prooftree}
\RightLabel{($\leq,\vee_1$)}
\AxiomC{}
\UnaryInfC{$A \leq A \vee B$}
\RightLabel{($\leq,\vee_2$)}
\AxiomC{}
\UnaryInfC{$A \leq A \vee B$}
\noLine
\BinaryInfC{}
\end{prooftree}

<p>
where the bound is the least upper bound
</p>

\begin{prooftree}
\RightLabel{($\leq,\vee$-bound)}
\AxiomC{$A \leq C$}
\AxiomC{$B \leq C$}
\BinaryInfC{$A \vee B \leq C$}
\end{prooftree}

<p>
Note that those bounds are unique up to equivalence, as they follow
also a categorical universal diagram, in this case, the coproduct
diagram
</p>

<p>
\[\begin{tikzcd}[column sep=tiny]
A \drar\ar[ddr, bend right] & & B \dlar\ar[ddl, bend left] \\
& A \vee B \dar[dashed] & \\
& C  & &.
\end{tikzcd}\]
</p>

<p>
This is a lattice, that has all finite meets and joins.
</p>
</div>
</div>

<div id="outline-container-org159a870" class="outline-3">
<h3 id="org159a870"><span class="section-number-3">2.7</span> Order-theoretic formulation of the implication</h3>
<div class="outline-text-3" id="text-2-7">
<p>
We have an exponential \(B^A\) whenever \(A \supset B\), this is defined
as the property
</p>

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$A\wedge (A \supset B) \leq B$}
\end{prooftree}

<p>
and the exponential is the universal element with this property
</p>

\begin{prooftree}
\AxiomC{$A \wedge C \leq B$}
\UnaryInfC{$C \leq A \supset B$}
\end{prooftree}
</div>
</div>

<div id="outline-container-org2026b09" class="outline-3">
<h3 id="org2026b09"><span class="section-number-3">2.8</span> Heyting algebra</h3>
<div class="outline-text-3" id="text-2-8">
<p>
A <b>Heyting algebra</b> is a lattice with exponentials.
</p>
</div>

<div id="outline-container-org3d73c0c" class="outline-4">
<h4 id="org3d73c0c"><span class="section-number-4">2.8.1</span> Yoneda Lemma</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
The Yoneda Lemma on lattices says that
</p>

<p>
\(a \leq b \iff \left(\forall x: x \leq a \implies x \leq b\right)\).
</p>

<p>
It is trivial by transitivity and identity. This is
an instance of a more general fact.
</p>
</div>
</div>
</div>
<div id="outline-container-org120b620" class="outline-3">
<h3 id="org120b620"><span class="section-number-3">2.9</span> Negation</h3>
<div class="outline-text-3" id="text-2-9">
<p>
We define \(\neg A := A \supset \bot\). It is the largest proposition inconsistent
with \(A\), the largest proposition such that \(A \wedge \neg A \leq \bot\).
</p>
</div>
</div>

<div id="outline-container-orgc6ae15e" class="outline-3">
<h3 id="orgc6ae15e"><span class="section-number-3">2.10</span> Complement</h3>
<div class="outline-text-3" id="text-2-10">
<p>
We define \(\overline{A}\) as the universal element with the property that \(\top \leq A \vee \overline{A}\)
and \(\overline{A} \wedge A \leq \bot\).
</p>

<p>
We have a complement distributive algebra (a boolean algebra!) and such thing
has exponentials.
</p>

\begin{prooftree}
\AxiomC{$\top \leq A \vee C$}
\UnaryInfC{$\overline{A} \leq C$}
\end{prooftree}
</div>
</div>

<div id="outline-container-orgc3c77c9" class="outline-3">
<h3 id="orgc3c77c9"><span class="section-number-3">2.11</span> Boolean algebra</h3>
<div class="outline-text-3" id="text-2-11">
<p>
A <b>boolean algebra</b> is a complemented distributive lattice. Therefore, it has
exponentials, defined as \(B^A := \overline{A} \vee B\).
</p>
</div>
</div>

<div id="outline-container-orgf1eab65" class="outline-3">
<h3 id="orgf1eab65"><span class="section-number-3">2.12</span> Completeness theorem</h3>
<div class="outline-text-3" id="text-2-12">
<p>
If \(A \leq B\) in every Heyting algebra, it must be deducible that \(A \vdash B\).
If something is valid in all models, in all Heyting algebras, it must be
provable.
</p>

<p>
This logic is complete for Heyting algebras, but it is not going to be
complete for boolean algebras. \(A \vee \neg A\) is not going to be provable in
our logic.
</p>
</div>

<div id="outline-container-org6fad72e" class="outline-4">
<h4 id="org6fad72e"><span class="section-number-4">2.12.1</span> Proof</h4>
<div class="outline-text-4" id="text-2-12-1">
<p>
If something is provable in every Heyting algebra, you can construct the
propositional <b>Lindenbaum algebra</b>; and this is used to show completenaess.
If \(A \leq B\) holds in every Heyting algebra, then \(A \text{ true} \vdash B \text{ true}\). We
need to interpret the propositions as elements on a Heyting algebra.
</p>
</div>
</div>

<div id="outline-container-orgcf16e55" class="outline-4">
<h4 id="orgcf16e55"><span class="section-number-4">2.12.2</span> Converse</h4>
<div class="outline-text-4" id="text-2-12-2">
<p>
If something is provable, it holds in every Heyting algebra. 
</p>
</div>
</div>
</div>

<div id="outline-container-org767a9e8" class="outline-3">
<h3 id="org767a9e8"><span class="section-number-3">2.13</span> Issue: negation and complement</h3>
<div class="outline-text-3" id="text-2-13">
<p>
In a boolean algebra, \(A \vee \neg A \simeq \top\).
</p>
</div>
</div>
</div>

<div id="outline-container-org7f0de96" class="outline-2">
<h2 id="org7f0de96"><span class="section-number-2">3</span> Lecture 3: Propositions as Types</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orga51d639" class="outline-3">
<h3 id="orga51d639"><span class="section-number-3">3.1</span> Last week</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Last week we saw IPL from a provability perspective. \(A\) is true if it
has a proof, and \(A\) is false if it has a refutation. We got the
structure of Heyting algebra (a lattice (partial order with all finite
meets and joins) and exponentials). Every Heyting algebra is
distributive. We defined the negation.
</p>
</div>

<div id="outline-container-orgbafaf59" class="outline-4">
<h4 id="orgbafaf59"><span class="section-number-4">3.1.1</span> Soundness incompleteness result</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
\(\Gamma \vdash A\) true iff \(\Gamma^{\ast} \leq A^{\ast}\) in every Heyting algebra.
</p>
</div>
</div>

<div id="outline-container-orgfcba6ad" class="outline-4">
<h4 id="orgfcba6ad"><span class="section-number-4">3.1.2</span> Boolean and Heyting algebras</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
Not every boolean algebra is a Heyting algebra, but every Heyting
algebra is a boolean algebra.
</p>
</div>
</div>

<div id="outline-container-org8e57e87" class="outline-4">
<h4 id="org8e57e87"><span class="section-number-4">3.1.3</span> DeMorgan Duality</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
\(\overline{A \wedge B} = \overline{A} \vee \overline{B}\) and \(\overline{A \vee B} = \overline{A} \wedge \overline{B}\).
</p>
</div>
</div>
</div>

<div id="outline-container-org15fdae7" class="outline-3">
<h3 id="org15fdae7"><span class="section-number-3">3.2</span> Claim</h3>
<div class="outline-text-3" id="text-3-2">
<p>
In IPL, not all instances of LEM are provable. We cannot prove
in general that \(A \vee \neg A \text{ true}\).
</p>
</div>

<div id="outline-container-orgeccb956" class="outline-4">
<h4 id="orgeccb956"><span class="section-number-4">3.2.1</span> Idea</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
The disjunction property says that if \(A \vee B \text{ true}\), then \(A\) true
or \(B\) true. This would imply that LEM gives us a proof or a
refutation of every element.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd669cf6" class="outline-3">
<h3 id="orgd669cf6"><span class="section-number-3">3.3</span> There exists a Heyting algebra which is not a boolean algebra</h3>
<div class="outline-text-3" id="text-3-3">
<p>
We need only a countermodel, a Heyting algebra where \(\top \leq A \vee \neg A\)
does not hold. It will show that this is not provable in general
in IPL.
</p>
</div>
</div>

<div id="outline-container-org287f38f" class="outline-3">
<h3 id="org287f38f"><span class="section-number-3">3.4</span> Decidable proposition</h3>
<div class="outline-text-3" id="text-3-4">
<p>
A proposition is <b>decidable</b> iff \(A \vee \neg A \text{ true}\). There are decidable
propositions even if LEM does not hold.
</p>
</div>

<div id="outline-container-org91f777d" class="outline-4">
<h4 id="org91f777d"><span class="section-number-4">3.4.1</span> Example</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
Two decidable propositions are \(\bot\) and \(\top\).
</p>

<p>
Equality on natural numbers will be decidable, but equality on reals
will not.
</p>
</div>
</div>
</div>
<div id="outline-container-orga6c6ce2" class="outline-3">
<h3 id="orga6c6ce2"><span class="section-number-3">3.5</span> Stable proposition</h3>
<div class="outline-text-3" id="text-3-5">
<p>
A proposition is <b>stable</b> iff \((\neg \neg A) \supset A \text{ true}\).
</p>
</div>
</div>

<div id="outline-container-orge69bd22" class="outline-3">
<h3 id="orge69bd22"><span class="section-number-3">3.6</span> Negation of the negation of LEM</h3>
<div class="outline-text-3" id="text-3-6">
<p>
We can prove \(\neg \neg (A \vee \neg A)\). This proves that not every proposition
is stable as a corollary.
</p>
</div>

<div id="outline-container-org21619a1" class="outline-4">
<h4 id="org21619a1"><span class="section-number-4">3.6.1</span> Proof</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
We will assume \(\neg (A \vee \neg A)\) and arrive at a contradiction. If we
assume \(A\), we have \(A \vee \neg A\), and then a contradiction, so it must
be the case that \(\neg A\). We know now that \(A \vee \neg A\), arriving at a
contradiction.
</p>
</div>
</div>
</div>

<div id="outline-container-org3846d76" class="outline-3">
<h3 id="org3846d76"><span class="section-number-3">3.7</span> Prove the disjunction property for IPL</h3>
<div class="outline-text-3" id="text-3-7">
<p>
We interpret the rules of IPL as an inductive definition of
the entailment relation.
</p>

<p>
We have finitary derivation trees of every \(\Gamma \vdash A\).
</p>
</div>

<div id="outline-container-org3af1adf" class="outline-4">
<h4 id="org3af1adf"><span class="section-number-4">3.7.1</span> Disjunction property: formal statement</h4>
<div class="outline-text-4" id="text-3-7-1">
<p>
If \(\varnothing \vdash A \vee B \text{ true}\), then \(\varnothing \vdash A \text{ true}\) or \(\varnothing \vdash B \text{ true}\).
</p>
</div>

<div id="outline-container-orgcc60e22" class="outline-5">
<h5 id="orgcc60e22"><span class="section-number-5">3.7.1.1</span> Counterexample if the context were not empty</h5>
<div class="outline-text-5" id="text-3-7-1-1">
<p>
If we take \(A \vee B\) as an assumption, this would trivially
not hold.
</p>
</div>
</div>
</div>
<div id="outline-container-org0cb946a" class="outline-4">
<h4 id="org0cb946a"><span class="section-number-4">3.7.2</span> Disjunction property: draft of a proof</h4>
<div class="outline-text-4" id="text-3-7-2">
<p>
We will use an induction on derivations. We examine all possible
derivations \(\varnothing \vdash A \vee B \text{ true}\) and show that there are derivations of
\(A\) or \(B\) also.
</p>

<p>
The last step of a derivation of \(A \vee B\) should be an introduction
\(\vee-I_{1}\) or \(\vee-I_2\); so there should be a derivation of \(A\) or \(B\) in
the previous step. The assumption rule is also not applicable.
Conjunction introduction is not applicable, and the same hold for
true introduction and implication introduction. Elimination rules
are our real problem here. For example, implication elimination should
be proved.
</p>

<p>
To prove this for the implication elimination rule, we suppose that
we have the derivations for \(\vdash C\) and \(C \vdash (A \vee B)\), and then we could
inline the first derivation using transitivity of entailment to get
a derivation of \(\vdash A \vee B\). Note that this is not a complete proof! the
derivation of \(C \supset (A \vee B)\) could have be done by other elimination
rules and we should prove that for them too.
</p>
</div>
</div>
</div>
<div id="outline-container-org63441c6" class="outline-3">
<h3 id="org63441c6"><span class="section-number-3">3.8</span> Structural properties are admissible</h3>
<div class="outline-text-3" id="text-3-8">
<p>
<b>Weakening is admissible</b>, if \(\Gamma \vdash_{IPL} B\text{ true}\), then \(\Gamma,A \text{ true} \vdash_{IPL} B \text{ true}\).
If you give a derivation of the first, you can get a derivation of the
second one.
</p>
</div>

<div id="outline-container-org259a53d" class="outline-4">
<h4 id="org259a53d"><span class="section-number-4">3.8.1</span> Why is weakening admissible</h4>
<div class="outline-text-4" id="text-3-8-1">
<p>
Because the rules are polymorphic! They do not depend of Gamma. We
could inductively weaken every step \(\Gamma \mapsto \Gamma,A\text{ true}\), and then, reapplying
the rules, would give us the same conclusion.
</p>
</div>
</div>

<div id="outline-container-org37083dc" class="outline-4">
<h4 id="org37083dc"><span class="section-number-4">3.8.2</span> Similarly</h4>
<div class="outline-text-4" id="text-3-8-2">
<p>
You could do exchange or contraction. But reflexivity is a primitive rule!
Transitivity for \(\text{IPL}^{-}\) is homework.
</p>
</div>
</div>
<div id="outline-container-org9369b2c" class="outline-4">
<h4 id="org9369b2c"><span class="section-number-4">3.8.3</span> We have now defined a good logic</h4>
<div class="outline-text-4" id="text-3-8-3">
<p>
It is not simply a bunch of rules, they follow a criteria. The
structural properties should hold. There are substructural logics,
but those are not our topic of interest.
</p>
</div>
</div>
</div>
<div id="outline-container-orgd8db50a" class="outline-3">
<h3 id="orgd8db50a"><span class="section-number-3">3.9</span> Gentzen's insight</h3>
<div class="outline-text-3" id="text-3-9">
<p>
Our previous idea to prove the disjunction property uses crucially an
inversion principle between implication introduction and implication
elimination.
</p>

<p>
<b>ELIM is post-inverse to INTRO.</b>
</p>

<p>
We are saying something like the following for introductions, eliminations
and derivations.
</p>

<ul class="org-ul">
<li>\((\wedge E_1 \circ \wedge I)({\cal D}_1,{\cal D}_2) = {\cal D}_1\)</li>
</ul>

<p>
This gives rise to a dynamics of proof! We do not only look at provability,
we look at the proofs per se.
</p>
</div>
</div>

<div id="outline-container-org7c0108d" class="outline-3">
<h3 id="org7c0108d"><span class="section-number-3">3.10</span> II. Proof relevant logic</h3>
<div class="outline-text-3" id="text-3-10">
<p>
We will write a grammar of proofs. \(M : A\) means that \(M\) is a proof
of \(A\). In correspondence with the assumptions, there is the concept
of variables
</p>

<p>
\[ x_1:A_1, \dots , x_n:A_n \vdash M : A.\]
</p>

<p>
Transitivity now reads as a substitution rule
</p>

\begin{prooftree}
\AxiomC{$\Gamma, x : A\vdash M : B$}
\AxiomC{$\Gamma \vdash N : A$}
\BinaryInfC{$[N/x]M : B$}
\end{prooftree}

<p>
and reflexivity is only a use of a variable
</p>

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma, x:A \vdash x : A$}
\end{prooftree}

<p>
We will write this derivations as mappings on a bicartesian closed category
</p>

<p>
\[M : A_1 \times \dots \times A_n \to A.
\]
</p>

<p>
Proof-relevant logic will give rise to Type Theory and Category Theory.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc014bd2" class="outline-2">
<h2 id="orgc014bd2"><span class="section-number-2">4</span> Lecture 4: Proof Reduction and Equivalence</h2>
<div class="outline-text-2" id="text-4">
<p>
We first saw logic from the point of view of provability. We are going
to look at the idea of logic with proofs. From the first, we got Heyting
Algebras; from the second, we are going to get bicartesian closed categories.
</p>

<p>
We going to define equivalence of proofs \(M \equiv N : A\).
</p>
</div>

<div id="outline-container-org5503ffb" class="outline-3">
<h3 id="org5503ffb"><span class="section-number-3">4.1</span> Proof terms</h3>
<div class="outline-text-3" id="text-4-1">
<p>
We will need a grammar of proofs to construct proof terms.
The structural properties are now properties for this grammar.
</p>

<ul class="org-ul">
<li>Reflexivity is now the introduction of a variable.</li>
<li>Transitivity is now the substitution of a variable.</li>
<li>Weakening is now the ability to discard variables.</li>
<li>Contraction is now a replication of variables.</li>
<li>Exchange is a permutation of variables.</li>
</ul>
</div>
</div>

<div id="outline-container-org8158b8b" class="outline-3">
<h3 id="org8158b8b"><span class="section-number-3">4.2</span> Logic</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Now the negative fragment of our logic can be written as
</p>

\begin{prooftree}
\RightLabel{$(\top_{I})$}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \left\langle  \right\rangle : \top$}
\end{prooftree}

\begin{prooftree}
\RightLabel{$(\wedge-I)$}
\AxiomC{$\Gamma \vdash M : A$}
\AxiomC{$\Gamma \vdash N : B$}
\BinaryInfC{$\Gamma \vdash \left\langle M,N \right\rangle : A \wedge B$}
\end{prooftree}

\begin{prooftree}
\RightLabel{$(\wedge_{E1})$}
\AxiomC{$\Gamma \vdash M : A \wedge B$}
\UnaryInfC{$\Gamma \vdash \text{fst}(M) : A$}
\RightLabel{$(\wedge_{E2})$}
\AxiomC{$\Gamma \vdash M : A \wedge B$}
\UnaryInfC{$\Gamma \vdash \text{snd}(M) : B$}
\noLine
\BinaryInfC{}
\end{prooftree}


\begin{prooftree}
\RightLabel{$(\supset_{I})$}
\AxiomC{$\Gamma, x:A \vdash M:B$}
\UnaryInfC{$\Gamma \vdash \lambda x . M : A \supset B$}
\end{prooftree}

\begin{prooftree}
\RightLabel{$(\supset_{E})$}
\AxiomC{$\Gamma \vdash M . A \supset B$}
\AxiomC{$\Gamma \vdash N : A$}
\BinaryInfC{$\Gamma \vdash M(N) : B$}
\end{prooftree}
</div>
</div>

<div id="outline-container-orge98794e" class="outline-3">
<h3 id="orge98794e"><span class="section-number-3">4.3</span> Gentzen's Inversion principle</h3>
</div>
<div id="outline-container-orgab18a0a" class="outline-3">
<h3 id="orgab18a0a"><span class="section-number-3">4.4</span> Definitional equality</h3>
<div class="outline-text-3" id="text-4-4">
<p>
In first order logic, no one draws a distinction between propositional
equality and definitional equality.
</p>

<p>
<b>Definitional equality</b> is the least congruence closed under the following
rules
</p>

<ul class="org-ul">
<li>it is a equivalence relation.</li>
<li>it is compatible with the rules.</li>
</ul>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M \equiv M' : A \wedge B$}
\UnaryInfC{$\Gamma \vdash \text{fst}(M) \equiv \text{fst}(M') : A$}
\end{prooftree}

<p>
Now the inversion principle can be written on proof terms.
Simplifications such as \(\text{fst}\left\langle M,N \right\rangle \equiv M\) are now useful if we
interpret this as a running program with proof dynamics.
</p>

<p>
Those are called Beta rules.
The inversion principle on conjunction is now
</p>

\begin{prooftree}
\RightLabel{$(\beta\wedge_1)$}
\AxiomC{$\Gamma \vdash M : A$}
\AxiomC{$\Gamma \vdash N : B$}
\BinaryInfC{$\Gamma \vdash \text{fst}\left\langle M,N \right\rangle \equiv M : A$}
\RightLabel{$(\beta\wedge_2)$}
\AxiomC{$\Gamma \vdash M : A$}
\AxiomC{$\Gamma \vdash N : B$}
\BinaryInfC{$\Gamma \vdash \text{snd}\left\langle M,N \right\rangle \equiv N : B$}
\noLine
\BinaryInfC{}
\end{prooftree}

<p>
The inversion principle on implication is inlining
</p>

\begin{prooftree}
\RightLabel{$(\beta\supset_1)$}
\AxiomC{$\Gamma,x:A \vdash M : B$}
\AxiomC{$\Gamma \vdash N : A$}
\BinaryInfC{$\Gamma \vdash (\lambda x. M)(N) \equiv [N/x]M : B$}
\end{prooftree}

<p>
Now we can compute by calculation with closed terms written
as \(M \equiv N\).
</p>
</div>
</div>

<div id="outline-container-org8b0ed70" class="outline-3">
<h3 id="org8b0ed70"><span class="section-number-3">4.5</span> Gentzen's Unicity Principles</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Those are \(\eta\) rules.
</p>

\begin{prooftree}
\RightLabel{$(\eta\top)$}
\AxiomC{$\Gamma \vdash M : \top$}
\UnaryInfC{$\Gamma \vdash M \equiv \left\langle  \right\rangle : \top$}
\end{prooftree}

\begin{prooftree}
\RightLabel{$(\eta\wedge)$}
\AxiomC{$\Gamma\vdash M: A \wedge B$}
\UnaryInfC{$M \equiv \left\langle \text{fst}(M),\text{snd}(M) \right\rangle$}
\end{prooftree}

\begin{prooftree}
\RightLabel{$(\wedge\supset)$}
\AxiomC{$\Gamma\vdash M:A \supset B$}
\UnaryInfC{$\Gamma\vdash M \equiv \lambda x. Mx : A \supset B$}
\end{prooftree}
</div>
</div>

<div id="outline-container-orgf5706ac" class="outline-3">
<h3 id="orgf5706ac"><span class="section-number-3">4.6</span> Propositions as types</h3>
<div class="outline-text-3" id="text-4-6">
<p>
The inversion and unicity principles will make a very strong
correspondence on categories.
</p>

\begin{tabular}{c|c|c|c}
Latticces & Propositions & Types & Categories \\
\hline
greatest & $\top$ & $1$ & final object \\
meets & $A \wedge B$ & $A \times B$ & finite products \\
exponential & $A \supset B$ & $A \to B$ & exponential \\
minimum & $\bot$ & $0$ & initial object \\
joins & $A \vee B$ & $A+B$ & coproducts
\end{tabular}
</div>
</div>

<div id="outline-container-orgc96337d" class="outline-3">
<h3 id="orgc96337d"><span class="section-number-3">4.7</span> Category</h3>
<div class="outline-text-3" id="text-4-7">
<p>
A <b>category</b> is a generalized preoder with evidence.
The difference between preorder and partial order is
related to univalence
</p>

\begin{prooftree}
\AxiomC{$A \leq B$}
\AxiomC{$B \leq A$}
\BinaryInfC{$A \equiv B$}
\end{prooftree}

<p>
where this is an instance of univalence. 
</p>

<p>
In a category we have the structure of a preorder
</p>

<ol class="org-ol">
<li>Reflexivity, \(\mathrm{id} : A \to A\).</li>
<li>Transitivity; if \(f: A \to B\) and \(g : B \to C\) then
\(g \circ f : A \to C\).</li>
</ol>

<p>
Those have to satisfy some coherence conditions, which are 
the following unit laws
</p>

<ul class="org-ul">
<li>\(\mathrm{id_B}\circ f = f = f \circ \mathrm{id_A}\)</li>
<li>\(f \circ (g \circ h) = (f\circ g)\circ h\)</li>
</ul>

<p>
The equality here is interesting. We could think of this structure
representing two paths and an homotopy between two paths on a 2-cell;
some kind of transformation. We are going to talk of a deformation
given by an associator
</p>

<p>
\[
\alpha : f \circ (g \circ h) \to (f \circ g) \circ h.
\]
</p>

<p>
And those notions of evidence (which act as natural transformations) need
also a notion of equivalence and a higher dimensional map between them. But 
this process could be repeated to infinity!
</p>

<p>
We are going to express the relation of types and terms in categorical terms.
</p>
</div>
</div>

<div id="outline-container-orgccd4d5b" class="outline-3">
<h3 id="orgccd4d5b"><span class="section-number-3">4.8</span> Terminal object</h3>
<div class="outline-text-3" id="text-4-8">
<p>
Definition of final object
</p>

\begin{prooftree}
\AxiomC{$$}
\UnaryInfC{$\left\langle\right\rangle : A \to 1$}
\AxiomC{$M : A \to 1$}
\RightLabel{$(\eta{\top})$}
\UnaryInfC{$M = \left\langle  \right\rangle : 1$}
\noLine
\BinaryInfC{}
\end{prooftree}

<p>
this was, in our old notation, \(A \vdash \left\langle  \right\rangle : 1 = \top\).
</p>
</div>
</div>

<div id="outline-container-org0108dd1" class="outline-3">
<h3 id="org0108dd1"><span class="section-number-3">4.9</span> Product objects</h3>
<div class="outline-text-3" id="text-4-9">
<p>
There are maps
</p>

<ol class="org-ol">
<li>\(\mathrm{fst} : A \times B \to A\)</li>
<li>\(\mathrm{snd} : A \times B \to A\)</li>
</ol>

<p>
satisfying
</p>

<p>
\[\begin{tikzcd}[column sep=tiny]
& D \ar[bend left]{ddr}{M}\ar[swap,bend right]{ddl}{N}\dar[dashed]{\exists!} & \\
& A \times B \drar[swap]{\mathrm{fst}} \dlar{\mathrm{snd}} & \\
A && B
\end{tikzcd}\]
</p>

<p>
Pairing is the function taking two functions and returning
the function to the product
</p>

\begin{prooftree}
\AxiomC{$M : D \to A$}
\AxiomC{$N : D \to B$}
\BinaryInfC{$\left\langle M,N \right\rangle : D \to A \times B$}
\end{prooftree}

<p>
algebraically,
</p>

<ul class="org-ul">
<li>\(\mathrm{fst}\circ \left\langle M,N \right\rangle = M : D \to A\)</li>
<li>\(\mathrm{snd}\circ \left\langle M,N \right\rangle = N : D \to B\)</li>
</ul>

<p>
and there is a uniqueness condition; given
</p>

\begin{prooftree}
\RightLabel{$(\eta \times)$}
\AxiomC{$P : D \to A \times B$}
\AxiomC{$\mathrm{fst} \circ P = M$}
\AxiomC{$\mathrm{snd} \circ P = N$}
\TrinaryInfC{$P = \left\langle M,N \right\rangle : D \to A \times B$}
\end{prooftree}

<p>
the uniqueness can be seen as the existence of homotopy between
any two functions making the product diagram commute.
</p>

<p>
In particular, \(\left\langle  \mathrm{fst}\circ P, \mathrm{snd} \circ P  \right\rangle = P\). Or we can say that \(\left\langle \mathrm{fst}, \mathrm{snd} \right\rangle = \mathrm{id}\)
or \(\left\langle M,N \right\rangle \circ P = \left\langle M\circ P,N \circ P \right\rangle\).
</p>

<p>
Lawvere and Lambek first saw those connections on the 70s.
</p>
</div>
</div>

<div id="outline-container-org65067d0" class="outline-3">
<h3 id="org65067d0"><span class="section-number-3">4.10</span> Exponentials</h3>
<div class="outline-text-3" id="text-4-10">
<p>
The exponential \(B^A\), gives the application map with the universal
diagram
</p>

<p>
\[\begin{tikzcd}
C \dar[dashed,swap]{\exists! \lambda(h)} & 
C \times A \ar{dr}{h}\dar[dashed,swap]{\lambda(h) \times id_A} & \\
B^{A} & B^{A} \times A \rar[swap]{app} & B \\
\end{tikzcd}\]
</p>

<p>
If we write that on syntax, that is equal to
</p>

<ul class="org-ul">
<li>\(app(\lambda(h) \times \mathrm{id}) = ap \circ \left\langle \lambda(h) \circ \mathrm{fst}, \mathrm{snd} \right\rangle = h\).</li>
<li>if there is any \(g\) such that \(ap \circ (g \times \mathrm{id}) = h\), then \(g = \lambda(h)\).</li>
</ul>

<p>
We get the \(\eta\text{-rule}\) of
</p>

<p>
\[
g = \lambda(\mathrm{ap} \circ (g \times \mathrm{id}))
  = \lambda(\mathrm{ap} \circ \left\langle g \circ \mathrm{fst}, \mathrm{snd} \right\rangle).
\]
</p>

<p>
The essence of all this is
</p>

\begin{prooftree}
\AxiomC{$\Gamma, x:A \vdash h : B$}
\UnaryInfC{$\Gamma \vdash \lambda x. h: B^A$}
\end{prooftree}
</div>
</div>

<div id="outline-container-org8d77ca5" class="outline-3">
<h3 id="org8d77ca5"><span class="section-number-3">4.11</span> DeBruijn indices</h3>
<div class="outline-text-3" id="text-4-11">
<p>
If we write contexts as \(A_{n-1}\times \dots \times A_{1}\), and we refer to the
variables using \(\mathrm{snd}(\mathrm{fst}(\mathrm{fst}\dots))\).
</p>
</div>
</div>
</div>

<div id="outline-container-org78af571" class="outline-2">
<h2 id="org78af571"><span class="section-number-2">5</span> Lecture 5: Universal properties</h2>
<div class="outline-text-2" id="text-5">
<p>
In the previous weeks we talked about
</p>

<ul class="org-ul">
<li>logic via provability and truth.</li>
<li>the entailment relation.</li>
<li>an order theoretic interpretation.</li>
<li>a logic for proofs with proof terms.</li>
<li>a notion of equality for proofs.</li>
</ul>
</div>

<div id="outline-container-orgbb77f23" class="outline-3">
<h3 id="orgbb77f23"><span class="section-number-3">5.1</span> Gentzen's inversion principle</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Represented on the \(\beta\) principles, rules such as
</p>

<ul class="org-ul">
<li>\(\mathtt{fst} \left\langle M,N \right\rangle \equiv M\)</li>
<li>\(\mathtt{snd} \left\langle M,N \right\rangle \equiv N\)</li>
<li>\((\lambda x. M)(N) \equiv [N/x]M\)</li>
<li>\(\mathtt{case}(\mathtt{inl}(M), x.P, y.Q) \equiv [M/x]P\)</li>
<li>\(\mathtt{case}(\mathtt{inr}(M), x.P, y.Q) \equiv [M/y]Q\)</li>
</ul>

<p>
they act as rules for proof simplification and can be interpreted as
a dynamics for proofs. Proofs are programs.
</p>
</div>
</div>

<div id="outline-container-org41e859e" class="outline-3">
<h3 id="org41e859e"><span class="section-number-3">5.2</span> Gentzen's unicity principles</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Represented on \(\eta\) principles.
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : \top$}
\UnaryInfC{$\Gamma \vdash M \equiv \langle\rangle : \top$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : A \wedge B$}
\UnaryInfC{$\Gamma \vdash M \equiv \left\langle \mathtt{fst}(M),\mathtt{snd}(M) \right\rangle : A \wedge B$}
\end{prooftree}

<p>
there is another way of saying this
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : A \wedge B$}
\AxiomC{$\Gamma \vdash \mathtt{fst}(M) \equiv P : A$}
\AxiomC{$\Gamma \vdash \mathtt{snd}(M) \equiv Q : B$}
\TrinaryInfC{$\Gamma \vdash M \equiv \left\langle P,Q \right\rangle : A \wedge B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : A \supset B$}
\UnaryInfC{$\Gamma \vdash M \equiv \lambda x. M(x) : A \supset B$}
\end{prooftree}
</div>
</div>

<div id="outline-container-org219bef0" class="outline-3">
<h3 id="org219bef0"><span class="section-number-3">5.3</span> Categorical interpretation</h3>
<div class="outline-text-3" id="text-5-3">
<p>
A derivation
</p>

<p>
\[
x_1:A_1,\dots,x_n:A_n \vdash M : A
\]
</p>

<p>
is interpreted as a morphism
</p>

<p>
\[
M : A_1 \times \dots \times A_n \to A\]
\[M \equiv N : A_1 \times \dots \times A_n \to A
\]
</p>

<p>
The product diagram relates
</p>

<ul class="org-ul">
<li>the existence with the introduction.</li>
<li>the uniqueness with the \(\eta\) rules.</li>
<li>the commutativity with the \(\beta\) rules.</li>
</ul>
</div>
</div>

<div id="outline-container-org2e4b97f" class="outline-3">
<h3 id="org2e4b97f"><span class="section-number-3">5.4</span> Unicity principle for the disjunction [40:00]</h3>
<div class="outline-text-3" id="text-5-4">
<p>
It is more difficult to see how the disjunction property should be
written. An inspiration is the notion of Shannon expansion: the type
of booleans can be written as \(\top \vee \top\); then \(\mathtt{case}\) acts as a binary decision 
diagram. The Shannon expansion is a substitution using booleans where
</p>

<ul class="org-ul">
<li>\(\mathtt{inl} \left\langle  \right\rangle \equiv true\)</li>
<li>\(\mathtt{inl} \left\langle  \right\rangle \equiv false\)</li>
</ul>

<p>
then
</p>

<p>
\[
[M/x]P \equiv \text{ if } M \text{ then } [true/x]P \text{ else } [false/x]P.
\]
</p>

<p>
and, in particular,
</p>

<p>
\[
P \equiv \text{ if } x \text{ then } [true/x]P \text{ else } [false/x]P.
\]
</p>

<p>
The eta rule for disjunction is then
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : A \vee B$}
\AxiomC{$\Gamma, z:A \vee B \vdash P : C$}
\BinaryInfC{$\Gamma \vdash [M/z]P \equiv \mathrm{case}(M; x : [\mathtt{inl}(x)/z]P; y : [\mathtt{inr}(y)/z]P) : C$}
\end{prooftree}

<p>
like a generalized Shannon expansion. As an special case, we
get that \(M \equiv \mathtt{case}(M, x . \mathtt{inl}(x), y . \mathtt{inr}(y))\).
</p>
</div>
</div>

<div id="outline-container-org6a3ae7b" class="outline-3">
<h3 id="org6a3ae7b"><span class="section-number-3">5.5</span> Remark</h3>
<div class="outline-text-3" id="text-5-5">
<p>
We could have defined the relationship on variables \(x \equiv \left\langle \mathtt{fst}(x), \mathtt{snd}(x) \right\rangle\), but
to derive the general rule from there, we would have needed another property
to get a correct substitution rule.
</p>
</div>
</div>

<div id="outline-container-org285a9c8" class="outline-3">
<h3 id="org285a9c8"><span class="section-number-3">5.6</span> Coproduct</h3>
<div class="outline-text-3" id="text-5-6">
<p>
We write the coproduct as \(A + B\), and its diagram as
</p>

<p>
\[\begin{tikzcd}[column sep=tiny]
& C  & \\
& A+B  \uar[dashed]{\exists! \left\{ P,Q \right\}}  & \\
A\ar[bend left]{uur}{P}       \urar[swap]{\mathtt{inl}} &&
B\ar[swap,bend right]{uul}{Q} \ular{\mathtt{inr}}
\end{tikzcd}\]
</p>

<p>
where
</p>

<p>
\[
\left\{ P,Q \right\} \equiv \mathtt{case} ( - , x.P, y.Q) 
\]
</p>

<p>
And the unicity simply says that
</p>

\begin{prooftree}
\AxiomC{$\Gamma, x:A \vdash [ \mathtt{inl}(x)/z ]M \equiv P : C$}
\AxiomC{$\Gamma, y:B \vdash [ \mathtt{inr}(y)/z ]M \equiv Q : C$}
\BinaryInfC{$\Gamma, z : A+B \vdash M \equiv \mathtt{case}(z,x:P,y:Q) : C$}
\end{prooftree}

<p>
This is an induction principle. We can caracterize the behaviour of \(M\) simply
by giving its behaviour on the \(\mathtt{inl}\) and the \(\mathtt{inr}\).
</p>
</div>
</div>
<div id="outline-container-org0d98bcf" class="outline-3">
<h3 id="org0d98bcf"><span class="section-number-3">5.7</span> Beta/eta rules</h3>
<div class="outline-text-3" id="text-5-7">
<p>
The beta rules are analytic judgements. Self-evident.
The eta rules are synthetic judgements. They require proof.
</p>

<p>
The beta rules correspond to definitional equality and the 
eta rules correspond to propositional equality; it will be
expressed typically by a type. The definitional equality, on
the other hand, is simply a judgement and it is also called
a judgmental equality.
</p>
</div>
</div>
</div>
<div id="outline-container-org385df4f" class="outline-2">
<h2 id="org385df4f"><span class="section-number-2">6</span> Lecture 6: Dependency, families of types</h2>
<div class="outline-text-2" id="text-6">
<p>
So far, we have seen a propositions/types correspondence.
We will add a type of natural numbers, and look for its correspondence
in intuitionistic logic.
</p>
</div>

<div id="outline-container-org86f3cb2" class="outline-3">
<h3 id="org86f3cb2"><span class="section-number-3">6.1</span> Gödel's T</h3>
<div class="outline-text-3" id="text-6-1">
<p>
We will call Gödel's T to the system we have developed so far plus
a natural numbers type. This is not exactly Gödel's T in the literature,
where it is defined only with function types.
</p>

\begin{prooftree}
\RightLabel{(Nat$_{I-0}$)}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash 0 : Nat$}
\RightLabel{(Nat$_{I-S}$)}
\AxiomC{$\Gamma \vdash M : Nat$}
\UnaryInfC{$\Gamma \vdash s(M) : Nat$}
\noLine
\BinaryInfC{}
\end{prooftree}

<p>
The elimination form is just definition by recursion
</p>

\begin{prooftree}
\RightLabel{(Nat$_{E}$)}
\AxiomC{$\Gamma \vdash M : Nat$}
\AxiomC{$\Gamma \vdash P : A$}
\AxiomC{$\Gamma, x:A \vdash Q:A$}
\TrinaryInfC{$\Gamma \vdash \mathtt{rec}(P,x.Q)(M) : A$}
\end{prooftree}

<p>
We need now two beta rules to comply with the inversion principle.
</p>

<ul class="org-ul">
<li>\(\mathtt{rec}(P,Q)(0) \equiv P\)</li>
<li>\(\mathtt{rec}(P,Q)(s(M)) \equiv [ \mathrm{rec}(P,Q)(M)/x ]Q\)</li>
</ul>

<p>
so, if \(\overline{n} = s(\dots s(0)\dots)\), \(\mathtt{rec}(P,Q)(\overline{n}) \equiv Q(Q(\dots (Q(P))\dots)\).
</p>

<p>
There is also a eta rule, that was not considered by Gödel at the moment.
Suppose an \(M\) acting the same way on the \(0\) and the \(s\), then it is the
recursor.
</p>

\begin{prooftree}
\AxiomC{$\Gamma,z : Nat \vdash M : A$}
\AxiomC{$\Gamma \vdash [0/z] M \equiv P:A$}
\AxiomC{$\Gamma, z:Nat \vdash [ S(z)/z ]M \equiv [M/x]Q$}
\TrinaryInfC{$\Gamma,z:Nat \vdash M \equiv \mathtt{rec}(P,Q)(z)$}
\end{prooftree}
</div>

<div id="outline-container-org22dea65" class="outline-4">
<h4 id="org22dea65"><span class="section-number-4">6.1.1</span> Special case on the recursor</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
Plugging naturals on the recursor
</p>

<p>
\(z : Nat \vdash \mathtt{rec}(0,y.s(y))(z) \equiv z : Nat\)
</p>
</div>
</div>

<div id="outline-container-org550cbf0" class="outline-4">
<h4 id="org550cbf0"><span class="section-number-4">6.1.2</span> Commuting conversion</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
\(\Gamma, z:Nat \vdash [ \mathtt{rec}(0,y.s(y))(z)/z  ]M \equiv \mathtt{rec}([0/z]M, y.[s(y)/z]M)(z)\)
</p>
</div>
</div>
</div>

<div id="outline-container-orgec7fff5" class="outline-3">
<h3 id="orgec7fff5"><span class="section-number-3">6.2</span> Natural numbers object in a category</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The natural numbers object is the universal object in the following
diagram
</p>

<p>
\[\begin{tikzcd}[column sep=huge]
1 \rar{0}\drar[swap]{P} &
\mathbb{N} \dar[dashed]{\exists! \mathtt{rec}(P,Q)} &
\mathbb{N} \rar{s}\dar[dashed]{\exists! \mathtt{rec}(P,Q)} &
\mathbb{N} \dar[dashed]{\exists! \mathtt{rec}(P,Q)} \\
&
A &
A \rar[swap]{Q}&
A
\end{tikzcd}\]
</p>
</div>
</div>

<div id="outline-container-org251dcf4" class="outline-3">
<h3 id="org251dcf4"><span class="section-number-3">6.3</span> Reorging the NNO into an initial algebra</h3>
<div class="outline-text-3" id="text-6-3">
<p>
This is equivalent to this universality property
</p>

<p>
\[\begin{tikzcd}[column sep=60pt]
1+\mathbb{N} \dar[swap]{\left\{ 0,s \right\}} \rar[dashed]{ id + \mathtt{rec}(P,Q) } & 
1+A \dar{\left\{ P,Q \right\}} \\
\mathbb{N} \rar[dashed]{\mathtt{rec}(P,Q)}  & 
A
\end{tikzcd}\]
</p>

<p>
where \(f+g : A+B \to A'+B'\) is defined componentwise on the coproduct.
</p>
</div>
</div>

<div id="outline-container-org939746e" class="outline-3">
<h3 id="org939746e"><span class="section-number-3">6.4</span> Initial algebras</h3>
<div class="outline-text-3" id="text-6-4">
<p>
This is an instance of a more general phenomenon, where a functor \(F\) satisfies
the diagram with the initial object \(I\).
</p>

<p>
\[\begin{tikzcd}
F(I)\rar{F(!)} \dar[swap]{i} & F(A) \dar{f} \\
I\rar{(!)} & A
\end{tikzcd}\]
</p>

<p>
This is called an <b>initial algebra</b>.
</p>
</div>
</div>

<div id="outline-container-org5db8c69" class="outline-3">
<h3 id="org5db8c69"><span class="section-number-3">6.5</span> Defining addition</h3>
<div class="outline-text-3" id="text-6-5">
<p>
We can define addition on the second argument
</p>

<p>
\(\mathtt{plus} := \lambda x. \lambda y. \mathtt{rec}(x;z.s(z))(y)\)
</p>

<p>
and we can check that \(\mathtt{plus}\ \overline{m}\ \overline{n} \equiv \overline{m+n}\). But we also can
define addition on the first \(\mathtt{q}:= \lambda x.\lambda y. \mathtt{p}\ y\ x\), and this also
implements addition: \(\mathtt{q}\ \overline{m}\ \overline{n} \equiv \overline{m+n}\).
</p>

<p>
Be we cannot prove
</p>

<p>
\[
x:Nat, y:Nat \vdash \mathtt{p}\ x\ y \equiv \mathtt{q}\ x\ y  \equiv \mathtt{p}\ y\ x
\]
</p>

<p>
as these are NOT definitionally equal! It can be proved that it is
not provable using only beta rules. This would require a proof by
induction: to show something for all the numerals is the same thing
as to show it for any numeral variables.
</p>
</div>
</div>

<div id="outline-container-org74a0b37" class="outline-3">
<h3 id="org74a0b37"><span class="section-number-3">6.6</span> Extensional and intensional equality</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Those are <b>extensionally</b> equal, but they are not intensionally equal
(definitional equality). They represent a different algorithm. In the
<b>sense of Frege</b>, they have the same reference, but not the same sense.
They have the same IO but different algorithms.
</p>

<ul class="org-ul">
<li>Extensional equality is analytic, it does not require proof.</li>
<li>Intensional equality is synthetic, does requires proof.</li>
</ul>

<p>
Extensional equality on \((\mathbb{N}\to \mathbb{N})\to(\mathbb{N}\to \mathbb{N})\) has a high quantifier
complexity. A bunch of nested forall and exist.
</p>
</div>
</div>

<div id="outline-container-orgad59140" class="outline-3">
<h3 id="orgad59140"><span class="section-number-3">6.7</span> Extensional equality</h3>
<div class="outline-text-3" id="text-6-7">
<p>
Intensional equality is an inductive defined judgment, whereas
Extensional equality is a proposition such as
</p>

<p>
\[ \mathtt{p}\ x\ y =_{Nat} \mathtt{q}\ x\ y
\]
</p>

<p>
that is an atomic proposition. By the propositions as types
principle, extensional equality is a family of types.
</p>

<p>
\[
x: Nat, y:Nat \vdash x = y \text{ type}
\]
</p>

<p>
sometimes \(x=y\) is written as \(Id_{Nat}(x,y)\). It is a propositional
function or a binary relation.
</p>

<p>
This family can be instantiated by substitution
</p>

<p>
\[
Id_{Nat}(M,N) \text{ type}
\]
</p>

<p>
whenever \(M,N:Nat\).
</p>
</div>
</div>

<div id="outline-container-orga2a67b6" class="outline-3">
<h3 id="orga2a67b6"><span class="section-number-3">6.8</span> Example of extensional equality</h3>
<div class="outline-text-3" id="text-6-8">
<p>
We can define the finite sequence of naturals of length \(x:Nat\)
</p>

<p>
\[
x : Nat \vdash Seq(x) \text{ type.}
\]
</p>

<p>
In this case, \(Seq(p\ \overline{m}\ \overline{n}) \equiv Seq(q\ \overline{m}\ \overline{n})\) because of the fact that
\(p\ \overline{m}\ \overline{n} \equiv q\ \overline{m}\ \overline{n}\). But
</p>

<p>
\[
x:Nat, y:Nat \vdash Seq(p\ x\ y) \not\equiv Seq(q\ x\ y)
\]
</p>

<p>
will not be definitionally equal. But they are isomorphic! In some
sense, they should be equivalent. \(A \simeq B\) should mean that for some
\(f,g\), we should get
</p>

<p>
\[\begin{aligned}
\alpha :&\quad g \circ f = \mathrm{id} \\
\beta :&\quad f \circ g = \mathrm{id}
\end{aligned}\]
</p>

<p>
but again, we are we meaning here by equality? In this case we are
talking about propositional equality. There should be transformations
\(\alpha,\beta\) between the compositions and the identities.
</p>
</div>
</div>

<div id="outline-container-org84061c0" class="outline-3">
<h3 id="org84061c0"><span class="section-number-3">6.9</span> Univalence axiom</h3>
<div class="outline-text-3" id="text-6-9">
<p>
In some sense, we expect them to be equal. Univalence says that \(A=B \iff A \simeq B\).
There will be an equivalence between those two types.
</p>
</div>
</div>
<div id="outline-container-orge93b693" class="outline-3">
<h3 id="orge93b693"><span class="section-number-3">6.10</span> Setup for dependent types</h3>
<div class="outline-text-3" id="text-6-10">
<p>
Context/closed types. We have judgements
</p>

<ul class="org-ul">
<li>\(\Gamma \text{ ctx}\)</li>
<li>\(\Gamma \equiv \Gamma'\)</li>
</ul>

<p>
Open types/families
</p>

<ul class="org-ul">
<li>\(\Gamma \vdash A \text{ type}\)</li>
<li>\(\Gamma : A \equiv A'\)</li>
</ul>

<p>
Elements of types
</p>

<ul class="org-ul">
<li>\(\Gamma \vdash M : A\)</li>
<li>\(\Gamma \vdash M \equiv M' : A\)</li>
</ul>

<p>
We will have a notion of empty context and the notion of adding anything
to a context
</p>

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\cdot \text{ ctx}$}
\AxiomC{$\Gamma \text{ ctx}$}
\AxiomC{$\Gamma \vdash A \text{ type}$}
\BinaryInfC{$\Gamma, x:A \text{ ctx}$}
\noLine
\BinaryInfC{}
\end{prooftree}

<p>
and the equality
</p>

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\cdot \equiv \cdot$}
\AxiomC{$\Gamma \equiv \Gamma'$}
\AxiomC{$\Gamma \vdash A \equiv A'$}
\BinaryInfC{$\Gamma, x:A \equiv \Gamma, x:A'$}
\noLine
\BinaryInfC{}
\end{prooftree}

<p>
we can take variables
</p>

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma,x:A,\Delta \vdash x :A $}
\end{prooftree}

<p>
here it is necessary a weakening rule
</p>

\begin{prooftree}
\AxiomC{$\Gamma,\Delta \vdash J$}
\AxiomC{$\Gamma \vdash A \text{ type}$}
\BinaryInfC{$\Gamma, x:A, \Delta \vdash J$}
\end{prooftree}

<p>
and a substitution
</p>

\begin{prooftree}
\RightLabel{(substitution/transitivity)}
\AxiomC{$\Gamma, x:A, \Delta \vdash J$}
\AxiomC{$\Gamma \vdash M:A$}
\BinaryInfC{$\Gamma [M/x]\Delta \vdash [M/x]J$}
\end{prooftree}

<p>
and the principle of functionality
</p>

\begin{prooftree}
\AxiomC{$\Gamma, x:A, \Delta \vdash N:B$}
\AxiomC{$\Gamma\vdash M\equiv M' :A$}
\BinaryInfC{$\Gamma [M/x] \Delta \vdash [M/x]N \equiv [M'/x]N : [M/x]B$}
\end{prooftree}

<p>
another simpler rule is
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M:A$}
\AxiomC{$\Gamma \vdash A \equiv A'$}
\BinaryInfC{$\Gamma \vdash M:A'$}
\end{prooftree}

<p>
and similarly
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M \equiv M':A$}
\AxiomC{$\Gamma \vdash A \equiv A'$}
\BinaryInfC{$\Gamma \vdash M\equiv M':A'$}
\end{prooftree}

<p>
All this is written on the section 2 of the appendix of HoTT.
</p>
</div>

<div id="outline-container-org937aedc" class="outline-4">
<h4 id="org937aedc"><span class="section-number-4">6.10.1</span> Exercise</h4>
<div class="outline-text-4" id="text-6-10-1">
<p>
Consider exchange and contraction
</p>
</div>
</div>
</div>
<div id="outline-container-orge06a46c" class="outline-3">
<h3 id="orge06a46c"><span class="section-number-3">6.11</span> Formation rules</h3>
<div class="outline-text-3" id="text-6-11">
<p>
The identity type is constructed as
</p>

\begin{prooftree}
\RightLabel{(Id-F)}
\AxiomC{$\Gamma \vdash A \text{ type}$}
\AxiomC{$\Gamma \vdash M:A$}
\AxiomC{$\Gamma \vdash N:A$}
\TrinaryInfC{$\Gamma \vdash Id_A(M,N) \text{ type}$}
\end{prooftree}

<p>
iterated identity types can be defined \(Id_{Id_A(M,N)}\) to any dimension.
The introduction rule should be
</p>

\begin{prooftree}
\RightLabel{(Id-I)}
\AxiomC{$\Gamma \vdash M:A$}
\UnaryInfC{$\Gamma \vdash \mathrm{refl}(M) : Id_A(M,M)$}
\end{prooftree}

<p>
being a witness of the fact that \(M\) is equal to itself.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc70f697" class="outline-2">
<h2 id="orgc70f697"><span class="section-number-2">7</span> Lecture 7: Dependent Types</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-org9c786e9" class="outline-3">
<h3 id="org9c786e9"><span class="section-number-3">7.1</span> Last week</h3>
<div class="outline-text-3" id="text-7-1">
<p>
The basic judgements are
</p>

<ol class="org-ol">
<li>\(\Gamma \text{ ctx}\)</li>
<li>\(\Gamma \equiv \Gamma'\)</li>
<li>\(\Gamma \vdash A \text{ type}\)</li>
<li>\(\Gamma \vdash A \equiv A'\)</li>
<li>\(\Gamma \vdash M:A\)</li>
<li>\(\Gamma \vdash M \equiv M' :A\)</li>
</ol>

<p>
and they follow structural properties. For example, typing respect definitional
equivalence
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M:A$}
\AxiomC{$\Gamma \vdash A \equiv A'$}
\BinaryInfC{$\Gamma \vdash M : A'$}
\end{prooftree}

<p>
We left open the exact formulation.
</p>
</div>

<div id="outline-container-orge92213b" class="outline-4">
<h4 id="orge92213b"><span class="section-number-4">7.1.1</span> Example</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
An example of dependent type is \(x : Nat \vdash Seq(x) \text{ text}\).
</p>

\begin{prooftree}
\AxiomC{$M \equiv M' : Nat$}
\UnaryInfC{$Seq(M) \equiv Seq(M')$}
\end{prooftree}

<p>
But we do not get \(x,y : Nat \not\vdash Seq(x+y) \equiv Seq(y+x)\). The
reason is that \(x + y \not\equiv y + x\), they are only intensionally equivalent.
To apply \(\eta\) you need to establish an invariant about a candidate \(M\),
and the \(\eta\) rule would not be enough to write a proof of induction of
that fact. We do not want an induction eta-rule.
</p>
</div>
</div>
</div>

<div id="outline-container-org142b0bb" class="outline-3">
<h3 id="org142b0bb"><span class="section-number-3">7.2</span> Proof-relevance</h3>
<div class="outline-text-3" id="text-7-2">
<p>
An element \(P : Id_A(M,N)\) can be seen as
</p>

<ol class="org-ol">
<li>a proof that \(M\) is \(N\).</li>
<li>an identification of \(M\) with \(N\).</li>
<li>a path from \(M\) to \(N\).</li>
</ol>

<p>
This \(x =_A y\) is called propositional equality.
</p>
</div>
</div>

<div id="outline-container-org015733f" class="outline-3">
<h3 id="org015733f"><span class="section-number-3">7.3</span> Generalization to dependent types</h3>
<div class="outline-text-3" id="text-7-3">
<p>
We will review the initial structure of types to generalize the
propositional negative connectives to their dependent forms.
For example, \(A \times B\) will generalize to a sigma type \(\sum_{x:A}B_x\);
and \(A \supset B\) generalizes to \(\prod_{x:A}B_{x}\).
</p>

<p>
\[
\prod_{x:Nat} \sum_{y:Nat} Id_{Nat}(y, \mathtt{succ}(x))
\]
</p>

<p>
They will represent logical conectives as
</p>

<p>
\[
\forall x:Nat. \exists y:Nat.\quad y = \mathtt{succ}(x).
\]
</p>
</div>
</div>

<div id="outline-container-org9eab3bf" class="outline-3">
<h3 id="org9eab3bf"><span class="section-number-3">7.4</span> Pi Types</h3>
<div class="outline-text-3" id="text-7-4">
<p>
Formation rules
</p>

\begin{prooftree}
\RightLabel{($\pi$-F)}
\AxiomC{$\Gamma \vdash A \text{ type}$}
\AxiomC{$\Gamma, x : A \vdash B_x \text{ type}$}
\BinaryInfC{$\Gamma \vdash \prod_{x:A}B_{x} \text{ type}$}
\end{prooftree}

<p>
introductory rules
</p>

\begin{prooftree}
\RightLabel{($\pi$-I)}
\AxiomC{$\Gamma, x:A \vdash M_{x} : B_{x}$}
\UnaryInfC{$\Gamma \vdash \lambda x. M_x : \prod_{x:A}B_{x}$}
\end{prooftree}

<p>
elimination rules
</p>

\begin{prooftree}
\RightLabel{($\pi$-E)}
\AxiomC{$\Gamma \vdash M : \prod_{x:A}B_x$}
\AxiomC{$\Gamma \vdash N:A$}
\BinaryInfC{$\Gamma \vdash MN : [N/x]B$}
\end{prooftree}

<p>
There is a beta-rule
</p>

<p>
\[
(\lambda x.M)N \equiv [N/x]M
\]
</p>

<p>
and an eta-rule
</p>

<p>
\[
(\lambda x.M x)\equiv M.
\]
</p>
</div>
</div>
<div id="outline-container-orgf8838d3" class="outline-3">
<h3 id="orgf8838d3"><span class="section-number-3">7.5</span> Particular case</h3>
<div class="outline-text-3" id="text-7-5">
<p>
\(A \supset B\) is a particular case of a pi-type where \(B\) does
not depends on \(A\).
</p>
</div>
</div>

<div id="outline-container-orgcf1147a" class="outline-3">
<h3 id="orgcf1147a"><span class="section-number-3">7.6</span> Sigma type</h3>
<div class="outline-text-3" id="text-7-6">
</div><div id="outline-container-org4a5b668" class="outline-4">
<h4 id="org4a5b668"><span class="section-number-4">7.6.1</span> Formation</h4>
<div class="outline-text-4" id="text-7-6-1">
\begin{prooftree}
\AxiomC{$\Gamma \vdash A \text{ type}$}
\AxiomC{$\Gamma, x:A \vdash B_{x} \text{ type}$}
\BinaryInfC{$\Gamma \vdash \sum_{x:A}B_x \text{ type}$}
\end{prooftree}
</div>
</div>

<div id="outline-container-orgb6f2c2c" class="outline-4">
<h4 id="orgb6f2c2c"><span class="section-number-4">7.6.2</span> Introduction</h4>
<div class="outline-text-4" id="text-7-6-2">
<p>
This is constructive existence, you are required to show evidence
of a particular case where it does hold
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M :A $}
\AxiomC{$\Gamma \vdash N : [M/x]B$}
\BinaryInfC{$\Gamma \vdash \left\langle M,N \right\rangle : \sum_{x:A} B_x$}
\end{prooftree}
</div>
</div>

<div id="outline-container-orgf886263" class="outline-4">
<h4 id="orgf886263"><span class="section-number-4">7.6.3</span> Particular case</h4>
<div class="outline-text-4" id="text-7-6-3">
<p>
The product of types is a particular case where \(B_x\) is
independent from \(x:A\).
</p>
</div>
</div>

<div id="outline-container-orgf712585" class="outline-4">
<h4 id="orgf712585"><span class="section-number-4">7.6.4</span> Elimination</h4>
<div class="outline-text-4" id="text-7-6-4">
<p>
Will not be the same as in the HoTT book.
</p>

\begin{prooftree}
\RightLabel{($\Sigma_{E_1}$)}
\AxiomC{$\Gamma \vdash M : \sum_{x:A} B_x$}
\UnaryInfC{$\Gamma \vdash \mathtt{fst}(M) : A$}
\RightLabel{($\Sigma_{E_2}$)}
\AxiomC{$\Gamma \vdash M : \sum_{x:A} B_x$}
\UnaryInfC{$\Gamma \vdash \mathtt{snd}(M) : [ \mathtt{fst}(M)/x]B_x$}
\noLine
\BinaryInfC{}
\end{prooftree}
</div>
</div>

<div id="outline-container-orgc394805" class="outline-4">
<h4 id="orgc394805"><span class="section-number-4">7.6.5</span> Beta/eta rules</h4>
<div class="outline-text-4" id="text-7-6-5">
<p>
Beta rules
</p>

<ul class="org-ul">
<li>\(\mathtt{fst}\left\langle M,N \right\rangle \equiv N\),</li>
<li>\(\mathtt{snd}\left\langle M,N \right\rangle \equiv N\)</li>
</ul>

<p>
and an eta-rule
</p>

<ul class="org-ul">
<li>\(\left\langle \mathtt{fst}(M), \mathtt{snd}(M) \right\rangle \equiv M\).</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org532492a" class="outline-3">
<h3 id="org532492a"><span class="section-number-3">7.7</span> Constructive logic</h3>
<div class="outline-text-3" id="text-7-7">
<p>
Can be seen as a refinment of classical logic, not as anything opposite
to it.
</p>
</div>
</div>
<div id="outline-container-org4492d63" class="outline-3">
<h3 id="org4492d63"><span class="section-number-3">7.8</span> Positive fragment</h3>
<div class="outline-text-3" id="text-7-8">
<p>
In the positive fragment, we have \((0,A+B,Nat,\dots)\). But are not
going to change the types. Issue: the positive elims reach into
arbitrary types.
</p>

<p>
For example, the elim of \(+\) was
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : A + B$}
\AxiomC{$\Gamma,x:A \vdash N:C$}
\AxiomC{$\Gamma, y:B \vdash P:C$}
\TrinaryInfC{$\Gamma \vdash \mathtt{case}(M,x.N,y.P) : C$}
\end{prooftree}

<p>
but here there is no dependency. \(C\) captures the join point of two
branches; or proof by cases.
</p>
</div>

<div id="outline-container-org452fea2" class="outline-4">
<h4 id="org452fea2"><span class="section-number-4">7.8.1</span> Example: induction</h4>
<div class="outline-text-4" id="text-7-8-1">
<p>
Let \(2 := 1 + 1\), \(tt := \mathtt{inl}\langle\rangle\) and \(ff := \mathtt{inr}\langle\rangle\). We define
</p>

<p>
\[ \mathtt{if}(M,N,P) := \mathtt{case}(M,-.N,-.P)
\]
</p>

<p>
and we want to prove that every element of \(2\) is one of those
</p>

<p>
\[
\prod_{x:2} \left( Id_2(x, \mathtt{tt}) + Id_2(x, \mathtt{ff}) \right).
\]
</p>

<p>
We have to prove both
</p>

<ul class="org-ul">
<li>\(Id_2(\mathtt{tt}, \mathtt{tt}) + Id_2(\mathtt{tt}, \mathtt{ff})\)</li>
<li>\(Id_2(\mathtt{ff}, \mathtt{tt}) + Id_2(\mathtt{ff}, \mathtt{ff})\)</li>
</ul>

<p>
So we use
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : A + B$}
\AxiomC{$\Gamma, z:A+B \vdash C_{z}$ type}
\AxiomC{$\Gamma, x:A \vdash N: [\mathtt{inl}(x)/z] C$}
\noLine
\UnaryInfC{$\Gamma, y:B \vdash P: [\mathtt{inr}(y)/z] C$}
\TrinaryInfC{$\Gamma \vdash \mathtt{case} [z.C] (M;x.N;y.P) : [M/z]C$}
\end{prooftree}

<p>
where \([z.C]\) is called the <b>motive</b> (term by Connor McBride). In this
particular case
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : 2$}
\AxiomC{$\Gamma, z:2 \vdash C_{z}$ type}
\AxiomC{$\Gamma\vdash N: [\mathtt{tt}/z] C$}
\noLine
\UnaryInfC{$\Gamma\vdash P: [\mathtt{ff}/z] C$}
\TrinaryInfC{$\Gamma \vdash \mathtt{if}(M;N;P) : [M/z]C$}
\end{prooftree}

<p>
This is a rule of induction.
</p>
</div>
</div>

<div id="outline-container-org909297e" class="outline-4">
<h4 id="org909297e"><span class="section-number-4">7.8.2</span> Example</h4>
<div class="outline-text-4" id="text-7-8-2">
<p>
We have the expression
</p>

<p>
\(\mathtt{if}(M,17, \mathtt{tt}) : \mathtt{if} (M,Nat,2)\)
</p>

<p>
but, it is a well-typed expression? not yet. We cannot type
those as types.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc77dc04" class="outline-3">
<h3 id="orgc77dc04"><span class="section-number-3">7.9</span> Induction on naturals</h3>
<div class="outline-text-3" id="text-7-9">
\begin{prooftree}
\AxiomC{$\Gamma \vdash M : Nat$}
\AxiomC{$\Gamma, z:Nat \vdash C \text{ type}$} 
\AxiomC{$\Gamma \vdash N : [0/z]C$}
\noLine
\UnaryInfC{$\Gamma,x:Nat, y:[x/z]C \vdash P:[s(x)/z]C$}
\TrinaryInfC{$\Gamma \vdash \mathtt{rec}[z.C](M,N;x,y.P) : [M/z]C$}
\end{prooftree}

<p>
with the two beta rules
</p>

<ul class="org-ul">
<li>\(\mathtt{rec}[z.C](0,N; x,y.P) \equiv N\)</li>
<li>\(\mathtt{rec}[z.C](s(M), N; x,y.P) \equiv [M, \mathtt{rec}[z.C](M,N;x,y.P)/x,y]P\)</li>
</ul>

<p>
It has an eta rule which is not useful.
</p>
</div>

<div id="outline-container-orgac32a59" class="outline-4">
<h4 id="orgac32a59"><span class="section-number-4">7.9.1</span> Exercise</h4>
<div class="outline-text-4" id="text-7-9-1">
<p>
\(\prod_{x:Nat} \left(Id(s(x),0) \to \bot\right)\)
</p>

<p>
we will use
</p>

<p>
\[
\lambda x. \mathtt{rec}[-](x; -,-)
\]
</p>
</div>
</div>

<div id="outline-container-orgd25f1c7" class="outline-4">
<h4 id="orgd25f1c7"><span class="section-number-4">7.9.2</span> Hard exercise</h4>
<div class="outline-text-4" id="text-7-9-2">
<p>
We cannot solve this yet
</p>

<p>
\(\prod_{x,y : Nat} (Id_{Nat}(sx,sy) \to Id_{Nat}(x,y))\)
</p>
</div>
</div>
</div>
<div id="outline-container-org5068550" class="outline-3">
<h3 id="org5068550"><span class="section-number-3">7.10</span> The other form of product types, sigma variant</h3>
<div class="outline-text-3" id="text-7-10">
<p>
Idea: elimination as pattern-matching.
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : \Sigma_{x:A}B_x$}
\AxiomC{$\Gamma, z : \Sigma_{x:A}B_x \vdash C \text{ type}$}
\AxiomC{$\Gamma, x:A, y:B \vdash P : [\langle x,y \rangle/z]C$}
\TrinaryInfC{$\Gamma \vdash \mathtt{split}[z.C](M;x,y.P) : [M/z]C$}
\end{prooftree}

<p>
the beta rule is
</p>

<ul class="org-ul">
<li>\(\mathtt{split}[z.C](\left\langle M_1,M_2 \right\rangle; x,y.P) \equiv [M_1,M_2/x,y]P\)</li>
</ul>

<p>
and the eta rule is similar to previous \(\eta\) rules. Anything like split is split.
</p>
</div>

<div id="outline-container-org68759db" class="outline-4">
<h4 id="org68759db"><span class="section-number-4">7.10.1</span> Exercise</h4>
<div class="outline-text-4" id="text-7-10-1">
<p>
Define <code>split</code> from fst,snd.
Define <code>fst</code>, <code>snd</code> from split. (Not yet)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb431791" class="outline-2">
<h2 id="orgb431791"><span class="section-number-2">8</span> Lecture 8: Identity types</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-orgd6994e5" class="outline-3">
<h3 id="orgd6994e5"><span class="section-number-3">8.1</span> Polarity</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Negative and positive fragments. The difference here is
if the type is based on the elimination or the introduction
rule; the other part of the rule is determined by this first
rule. In category theory, it corresponds to the universal
property mapping <i>in</i> or <i>out</i> the definition of the type.
</p>

\begin{tabular}{c|cc}
            & negative    & positive     \\
\hline
type theory & elimination & introduction \\
category theory & UP mapping in & UP mapping out
\end{tabular}

<p>
For example, \(A\times B\) is <i>negative</i>. We write the elimination rule:
given a product, we have <code>fst</code> and <code>snd</code>. The introduction rule is
a pair, needing an \(A\) and a \(B\).
</p>
</div>
</div>
<div id="outline-container-org30a337a" class="outline-3">
<h3 id="org30a337a"><span class="section-number-3">8.2</span> Last week</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Dependent formulations of 
</p>

<ol class="org-ol">
<li>negatives \(\Pi,\Sigma\).</li>
<li>positives, the type does not change, but the elimination forms do;
they become induction principles</li>
</ol>

<p>
Elim for the booleans is an example of branching. Today
</p>

<ul class="org-ul">
<li>identity types</li>
<li>universes</li>
<li>ITT. Limitations and peculiarities</li>
</ul>
</div>
</div>

<div id="outline-container-orgd3b523f" class="outline-3">
<h3 id="orgd3b523f"><span class="section-number-3">8.3</span> Identity types</h3>
<div class="outline-text-3" id="text-8-3">
<p>
They have this rule of formation
</p>

\begin{prooftree}
\RightLabel{(Id-F)}
\AxiomC{$\Gamma \vdash A \text{ type}$}
\AxiomC{$\Gamma \vdash M : A$}
\AxiomC{$\Gamma \vdash N : A$}
\TrinaryInfC{$\Gamma \vdash Id_A(M,N) \text{ type}$}
\end{prooftree}

<p>
if we read this type propositionally, this is the type of proofs of
equality between \(M\) and \(N\). As a notation we use \(M =_A N\).
</p>

\begin{prooftree}
\RightLabel{(Id-T)}
\AxiomC{$\Gamma \vdash M : A$}
\UnaryInfC{$\Gamma \vdash \mathtt{refl}_A(M) : Id_A(M,M)$}
\end{prooftree}

<p>
In ITT, this would be the only intro rule. We can think of \(Id\) as an
inductively generated family of types. 
</p>
</div>
</div>

<div id="outline-container-orgc51a936" class="outline-3">
<h3 id="orgc51a936"><span class="section-number-3">8.4</span> Elimination rule for identity types</h3>
<div class="outline-text-3" id="text-8-4">
<p>
The elimination rule would then work as
</p>

\begin{prooftree}
\RightLabel{(Id-E)}
\AxiomC{$\Gamma \vdash P: Id_{A}(M,N)$}
\AxiomC{$\Gamma, x:A, y:A, z:Id_A(x,y) \vdash C \text{ type}$}
\AxiomC{$\Gamma, x:A \vdash Q: [x,x,\mathtt{refl}(x)/x,y,z]C$}
\TrinaryInfC{$\Gamma \vdash J[x,y,z.C](P;x.Q) : [M,N,P/x,y,z]C$}
\end{prooftree}

<p>
This principle is called <b>path induction</b>, where a path is an element
of the identity type. The beta rule is then
</p>

<ul class="org-ul">
<li>\(J[x,y,z.C]( \mathtt{refl}(M), x.Q) \equiv [M/x]Q : [M,M, \mathtt{refl}(M)/x,y,z]C\)</li>
</ul>

<p>
This \(J\) is the computational content of the proofs by path induction.
</p>
</div>
</div>
<div id="outline-container-orgc6d60d4" class="outline-3">
<h3 id="orgc6d60d4"><span class="section-number-3">8.5</span> Equivalence relation of identity</h3>
<div class="outline-text-3" id="text-8-5">
<p>
The identity type should be an equivalence relation
</p>

<ol class="org-ol">
<li>it is reflexive by definition, \(Id_A(M,M) \text{ true}\).</li>
<li><p>
it is symmetric showing that there is a function
</p>

<p>
\[ \mathtt{sym}_A : \prod_{x,y:A}Id_A(x,y) \to Id_A(y,x)
    \]
</p></li>

<li><p>
it is transitive with
</p>

<p>
\[ \mathtt{trans}_A:
    \prod_{x,y,z:A} Id_A(x,y) \to Id_A(y,z) \to Id_A(x,z)
    \]
</p></li>
</ol>

<p>
To define symmetry, we will take
</p>

<p>
\[ \mathtt{sym}_A :=
\lambda x,y:A.\quad \lambda z:Id_A(x,y).\quad
J[x,y, - : Id_A(y,x)}](z;x. \mathtt{refl}_A(x))
\]
</p>

<p>
Note that \(\mathtt{sym}(M)(M)(\mathtt{refl}(M)) \equiv \mathtt{refl}(M)\) due to the beta rule for \(J\).
</p>

<p>
To define transitivity 
</p>

<p>
\[ \mathtt{trans}_A :=
\lambda m,n,p. \ \lambda u{:}Id_A(m,n).\ \lambda v{:} Id_A(n,p).\  
(J[x,y, -:Id_A(y,p) \to Id(x,p) ](u; x.\lambda w.w))(v)
\]
</p>

<p>
Note that, in particular, \(\mathtt{trans}(M)(M)(P)(\mathtt{refl_A(M)})(Q) \equiv Q\).
</p>
</div>

<div id="outline-container-orgb64b511" class="outline-4">
<h4 id="orgb64b511"><span class="section-number-4">8.5.1</span> Exercise</h4>
<div class="outline-text-4" id="text-8-5-1">
<p>
Find two other proofs, not definitionally equivalent, of transitivity.
Hint: double induction.
</p>
</div>
</div>
</div>
<div id="outline-container-orgfc36456" class="outline-3">
<h3 id="orgfc36456"><span class="section-number-3">8.6</span> Simple functionality</h3>
<div class="outline-text-3" id="text-8-6">
<p>
Suposse \(x:A\vdash F:B\) where \(A,B\) are types. We have \(F\colon A \to B\).
We would like to have a way to prove that maps preserve equality
</p>

<p>
\[
x,y{:}A, u{:}Id_A(x,y) \vdash Id_B(Fx,Fy)
\]
</p>

<p>
We will define \(\mathtt{ap}\ F\ u\), also called \(F(|u|)\); the functorial action
</p>

<p>
\[ \mathtt{ap}\ F\ u = 
J[x,y, -:Id_B(Fx,Fy)](u, x. \mathtt{refl}_B(F\ x))
\]
</p>
</div>
</div>

<div id="outline-container-org24aad12" class="outline-3">
<h3 id="org24aad12"><span class="section-number-3">8.7</span> Transportation property</h3>
<div class="outline-text-3" id="text-8-7">
<p>
Suposse \(x:A \vdash B \text{ type}\), two pictures are useful
</p>

<ol class="org-ol">
<li>Assigning \(a{:}A \mapsto B[a]\) should be functorial.</li>
<li>\(\int_{A} B\) should have a display map with fibers sending elements
on \(B[a]\) to \(a\).</li>
</ol>

<p>
In some sense, \(a = a'\) must imply \(B[a] \simeq B[a']\). Transportation could
be thought as functionality for families.
</p>

<p>
We would want to have 
</p>

<p>
\[
m,m':A, u:Id_A(m,m'), v : [m/x]B \vdash \mathtt{tr}[x.B](u)(v) : [m'/x]B
\]
</p>

<p>
the notation for \(\mathtt{tr}[x.B](u)(v)\) is \(u_{\ast}(v)\).
</p>

<p>
This should be defined using path induction
</p>

<p>
\[ \mathtt{tr}[x.B](u)(v) :=
J\Big[x,y, -:[x/z]B \to [y/z]B\Big](u; z. \lambda w.w)(v)
\]
</p>
</div>
</div>

<div id="outline-container-org5cd7f3f" class="outline-3">
<h3 id="org5cd7f3f"><span class="section-number-3">8.8</span> Exercise</h3>
<div class="outline-text-3" id="text-8-8">
<p>
Find a map 
</p>

<p>
\[
x,y{:}Nat \vdash  -{:} Seq(x+y) \to Seq(y+x)
\]
</p>

<p>
To do this we need
</p>

<ol class="org-ol">
<li>to find a path \(x,y{:} Nat \vdash -{:}x+y =_{Nat} y+x\).</li>
<li>transport along that path.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org515672d" class="outline-2">
<h2 id="org515672d"><span class="section-number-2">9</span> Lecture 9: Universes</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-org191ceee" class="outline-3">
<h3 id="org191ceee"><span class="section-number-3">9.1</span> Last week</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Maps preserve proofs of identity (functionality)
</p>

<ul class="org-ul">
<li>if \(F \colon A \to B\) and \(p : Id_A(a,a')\), then \(\mathtt{ap}\ f\ p : Id_B(f(a),f(a'))\).
If \(a = a'\) is true, \(f(a) = f(a')\) is true.</li>
</ul>

<p>
The transportation creates isomorphisms between families of types.
</p>

<ul class="org-ul">
<li>If \(x:A\vdash B\) is a type and \(p : Id_A(a,a')\), then
\(\mathtt{tr}[x.B](p) : B[a] \to B[a']\). This is family functionality.
If \(a=a'\), then \(B[a] \iff B[a']\).</li>
</ul>
</div>
</div>
<div id="outline-container-orga137b58" class="outline-3">
<h3 id="orga137b58"><span class="section-number-3">9.2</span> Universes and large elims</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Last notion on ITT.
</p>
</div>

<div id="outline-container-org6844e30" class="outline-4">
<h4 id="org6844e30"><span class="section-number-4">9.2.1</span> Example</h4>
<div class="outline-text-4" id="text-9-2-1">
<p>
We defined \(\mathtt{if}(M,N;P) : B[M]\), and we would want to write things like
\(\mathtt{if}(M;17;\mathtt{tt}) : \mathtt{if}(M; Nat,Bool)\); a type depending on a boolean. But we cannot
write it because those are types instead of terms.
</p>
</div>
</div>

<div id="outline-container-org08afe61" class="outline-4">
<h4 id="org08afe61"><span class="section-number-4">9.2.2</span> Large eliminations (ad hoc)</h4>
<div class="outline-text-4" id="text-9-2-2">
<p>
We simply introduce a new type
</p>

\begin{prooftree}
\AxiomC{$M:Bool$}
\AxiomC{$A$ type}
\AxiomC{$B$ type}
\TrinaryInfC{$IF(M,A,B)$ type}
\end{prooftree}

<p>
where
</p>

<ul class="org-ul">
<li>\(IF(\mathtt{tt},A,B) \equiv A\)</li>
<li>\(IF(\mathtt{ff},A,B) \equiv B\)</li>
</ul>

<p>
Those are called <b>large eliminations</b>.
</p>
</div>
</div>

<div id="outline-container-org1733d40" class="outline-4">
<h4 id="org1733d40"><span class="section-number-4">9.2.3</span> Universes of types</h4>
<div class="outline-text-4" id="text-9-2-3">
<p>
A <b>universe</b> is a type of types.
</p>

\begin{prooftree}
\AxiomC{}
\UnaryInfC{${\cal U}$ type}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{${\cal U} \equiv {\cal U}$}
\end{prooftree}

<p>
where the introduction rules are the previous formation rules.
For example,
</p>

\begin{prooftree}
\RightLabel{(UI-Id)}
\AxiomC{$A: {\cal U}$}
\AxiomC{$M,N:A$}
\BinaryInfC{$Id_A(M,N) : {\cal U}$}
\end{prooftree}

<p>
The universe should be closed to type formation, for example, closed
to pi-types, sigma-types, 0, 1, sum of two types&#x2026;
</p>

\begin{prooftree}
\AxiomC{$A : {\cal U}$}
\AxiomC{$x:A \vdash B:{\cal U}$}
\BinaryInfC{$\prod_{x:A} B:{\cal U}$}
\end{prooftree}

<p>
But we do NOT postulate that \({\cal U} : {\cal U}\). Its formation rule is the unique
formation rule that is not translated. In other way, the Burali-Forte
Paradox could be reproduced.
</p>
</div>
</div>

<div id="outline-container-org70a9695" class="outline-4">
<h4 id="org70a9695"><span class="section-number-4">9.2.4</span> Solving the problem with universes</h4>
<div class="outline-text-4" id="text-9-2-4">
<p>
Now, we could form \(\mathtt{if}(M,Nat,Bool) : {\cal U}\); except we should define some
elimination rules.
</p>

<p>
Universes allow us to prove
</p>

<ul class="org-ul">
<li>injectivity of succ.</li>
<li>define <code>fst</code>, <code>snd</code> from <code>split</code>.</li>
</ul>

<p>
If we were to have large elims, we could write things like \(\mathtt{If}(M,U,U\to U)\); but
not with the universal type, where is not true that \(U : U\).
</p>
</div>
</div>
</div>

<div id="outline-container-org7fdfc9a" class="outline-3">
<h3 id="org7fdfc9a"><span class="section-number-3">9.3</span> Hierarchy of universes</h3>
<div class="outline-text-3" id="text-9-3">
<p>
To solve previous problems, we could write a cumulative hierarchy of
universes. We have a family of rules
</p>

\begin{prooftree}
\RightLabel{(U-I)}
\AxiomC{$$}
\UnaryInfC{${\cal U}_i : {\cal U}_{i+1}$}
\RightLabel{(U-$\equiv$)}
\AxiomC{$$}
\UnaryInfC{${\cal U}_i \equiv {\cal U}_{i}$}
\noLine\BinaryInfC{}
\end{prooftree}

<p>
defining \({\cal U}_1,{\cal U}_2,\dots\) with a trivial definitional equality and closure
properties for every universe, for example
</p>

\begin{prooftree}
\AxiomC{$A : {\cal U}_i$}
\AxiomC{$x:A \vdash B:{\cal U}_i$}
\BinaryInfC{$\prod_{x:A} B:{\cal U}_i$}
\end{prooftree}

<p>
and the <b>principle of cumulativity</b>
</p>

\begin{prooftree}
\RightLabel{(cumulativity)}
\AxiomC{$A:{\cal U}_i$}
\UnaryInfC{$A : {\cal U}_{i+1}$}
\RightLabel{(cumulativity-$\equiv$)}
\AxiomC{$A \equiv B : {\cal U}_{i}$}
\UnaryInfC{$A \equiv B : {\cal U}_{i+1}$}
\noLine\BinaryInfC{}
\end{prooftree}

<p>
This architecture is forced on us by the Burali-Forte paradox. This
corresponds to the idea of inaccesible cardinals; to a size hierarchy.
</p>
</div>
</div>
<div id="outline-container-org1c71f95" class="outline-3">
<h3 id="org1c71f95"><span class="section-number-3">9.4</span> Dimension</h3>
<div class="outline-text-3" id="text-9-4">
<p>
There will be another different notion (on a different axis) than
size (universes). Dimensions are new in HoTT.
</p>
</div>
</div>

<div id="outline-container-orgb763947" class="outline-3">
<h3 id="orgb763947"><span class="section-number-3">9.5</span> Formation rules in HoTT</h3>
<div class="outline-text-3" id="text-9-5">
<p>
In the HoTT book, formation rules are written as introductions to
the universal type
</p>

\begin{prooftree}
\AxiomC{$A : {\cal U}$}
\AxiomC{$x:A \vdash B:{\cal U}$}
\BinaryInfC{$\prod_{x:A} B : {\cal U}$}
\end{prooftree}

<p>
This uses <b>typical ambiguity</b>, \({\cal U}\) can be \({\cal U}_i\). The type inference algorithms
of proof assistants solve these constraints, specifying the level in which
we are working. Is a kind of Universe Polymorphism: it let you pretend
\({\cal U} : {\cal U}\).
</p>

<p>
It is very difficult to write something where it is not possible to get an
error at the time of inferring universes. The Burali-Forte paradox cannot be
written in this setting.
</p>
</div>
</div>

<div id="outline-container-orgf071cb9" class="outline-3">
<h3 id="orgf071cb9"><span class="section-number-3">9.6</span> ITT</h3>
<div class="outline-text-3" id="text-9-6">
<p>
At this point, we have introduced ITT with Nats, Sigma, Pi, Identity and
Universes. [Martin-Löf 73]
</p>
</div>

<div id="outline-container-org4be08b3" class="outline-4">
<h4 id="org4be08b3"><span class="section-number-4">9.6.1</span> Theorem of Choice in ITT</h4>
<div class="outline-text-4" id="text-9-6-1">
<p>
When \(C\) is a total relation, we can pick up a canonical representative of
the elements to which \(x\) is related to.
</p>

<p>
\[
\left(\prod_{x:A} \sum_{y:B} C(x,y)\right) \to \sum_{f:A\to B}\prod_{x:A} C(x,f(x))
\]
</p>

<p>
where \(f\) is called the choice function.
</p>

<p>
In set theory, this is indepent of the axioms of sets; but in type
theory, it is a theorem because of proof-relevance.
</p>

<p>
\[
\lambda F.\ 
\left\langle \lambda x. \mathtt{fst}(F(x)) , \lambda x. \mathtt{snd}(F(x)) \right\rangle
\]
</p>

<p>
where \(\mathtt{snd}(F(x)) = C(x, \mathtt{fst}(F(x)))\). 
</p>
</div>
</div>

<div id="outline-container-org7137661" class="outline-4">
<h4 id="org7137661"><span class="section-number-4">9.6.2</span> Axiom of choice on sets</h4>
<div class="outline-text-4" id="text-9-6-2">
<p>
How about translating this proof to set theory? We would need for the proof
to be a parametrized object! Proof relevance is key to prove the theorem of
choice. If we cannot look inside the first proof, we could not prove the
theorem.
</p>
</div>
</div>
</div>

<div id="outline-container-org668ca94" class="outline-3">
<h3 id="org668ca94"><span class="section-number-3">9.7</span> Martin-Lof theorem</h3>
<div class="outline-text-3" id="text-9-7">
<p>
If \(p:Id_A(M,N)\) for any closed \(M,N,A\); without hypothesis (a theorem),
then \(M \equiv N : A\).
</p>
</div>

<div id="outline-container-org9bfb1d3" class="outline-4">
<h4 id="org9bfb1d3"><span class="section-number-4">9.7.1</span> Example</h4>
<div class="outline-text-4" id="text-9-7-1">
<p>
If we have that 
</p>

<p>
\(A = Nat \to Nat \to Nat\)
\(M = \lambda x. \lambda y.\ x+y\)
\(N = \lambda x. \lambda y.\ y+x\)
\(M \not\equiv N\)
</p>

<p>
There is no proof \(p : Id(M,N)\), no term of that type. Yet, given \(x,y,z: Nat\),
there exists a proof of \(p : Id(x+y,y+x)\). The axiom of extensionality fails
here. It is NOT true that
</p>

\begin{prooftree}
\AxiomC{$x : A \vdash p:Id_{B}(fx,gx)$}
\UnaryInfC{\vdash -:Id$_{A\to B}(f,g)$}
\end{prooftree}

<p>
So the ordinary notion of function is not true here anymore. We cannot
even prove that \(\lambda x.fx = \lambda x.gx\). This is a weakness of ITT.
</p>
</div>
</div>

<div id="outline-container-org1f111a7" class="outline-4">
<h4 id="org1f111a7"><span class="section-number-4">9.7.2</span> Function extensionality as an axiom</h4>
<div class="outline-text-4" id="text-9-7-2">
<p>
If we introduce extensionality as an axiom, we would have introduced another
intro for identity types, and \(J\) should have to be redefined.
</p>

<p>
In HoTT, we can construct this from the axioms, and this makes very difficult
the task of giving it a meaningful computational interpretation.
</p>
</div>
</div>
</div>

<div id="outline-container-org8e007ee" class="outline-3">
<h3 id="org8e007ee"><span class="section-number-3">9.8</span> Extensional theory of types (ETT)</h3>
<div class="outline-text-3" id="text-9-8">
<p>
In ETT (Extensional here has another meaning), the only identifications are
<code>refl</code>. We have the principle of <b>identity reflection</b>
</p>

\begin{prooftree}
\AxiomC{$p : Id_{A}(M,N)$}
\UnaryInfC{$M \equiv N : A$}
\end{prooftree}

<p>
and the only possible proof of identity is <code>refl</code>
</p>

\begin{prooftree}
\AxiomC{$p : Id_{A}(M,N)$}
\UnaryInfC{$p \equiv \mathtt{refl}(M): Id_A(M,N)$}
\end{prooftree}

<p>
In this case, the problem is solved. \(Id_B(fx,gx)\) gives us \(fx \equiv gx\),
so \(\lambda x. fx \equiv \lambda x. gx\), and by eta-reduction, \(f \equiv g\). This implies function
extensionality and obviates the need for a rule of transport, we can in fact
show that \(B[a] \equiv B[a']\). NuPRL was based on ETT, Coq is based on ITT.
</p>
</div>
</div>

<div id="outline-container-org1538f01" class="outline-3">
<h3 id="org1538f01"><span class="section-number-3">9.9</span> The disadvantage of ETT</h3>
<div class="outline-text-3" id="text-9-9">
<p>
\(M:A\) is decidable (not feasible) in ITT, while \(M : A\) is undecidable in ETT.
We need arbitrary theorem proving to decide the equality on ETT. It is instead
decidable if a derivation is a valid one.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf6f0e10" class="outline-2">
<h2 id="orgf6f0e10"><span class="section-number-2">10</span> Lecture 10: Groupoid structure of types</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-org3fe428d" class="outline-3">
<h3 id="org3fe428d"><span class="section-number-3">10.1</span> Last week</h3>
<div class="outline-text-3" id="text-10-1">
<p>
We considered ITT vs ETT. ETT has advantages
</p>

<ul class="org-ul">
<li>in ETT, there is no necessity for transport.</li>
<li>ETT is similar to standard mathematics, in that there is "just
equality".</li>
<li>function extensionality is implied from the rules.</li>
</ul>

<p>
And disadvantages
</p>

<ul class="org-ul">
<li>type checking is no longer decidable; judgmental equality
is not decidible and it involves proof search and arbitrary theorem
proving.</li>
</ul>

<p>
A <b>setoid</b> in ITT is a set with a given equivalence relation chosen to
have properties like function extensionality. So, the alternative to ETT
is to work with setoids on ITT.
</p>

<p>
Types are (limited to) sets (aka hsets). The reason why ETT looks like standard
mathematics is because we are working with Sets, where the only paths/identifications
are reflexivities. A sufficient condition for being discrete is decibility of equality.
</p>
</div>
</div>

<div id="outline-container-org7807a1f" class="outline-3">
<h3 id="org7807a1f"><span class="section-number-3">10.2</span> Groupoids</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Types in ITT, in contrast, are more general. They are \(\infty\text{-groupoids}\), 
and they have richer path structure. Paths can be composed
</p>

<ul class="org-ul">
<li>\(p : Id_A(a,b)\)</li>
<li>\(q : Id_A(b,c)\)</li>
</ul>

<p>
When ITT was introduced, it had power to use gropoids. At the very
beginning, no one realized this feature. ETT works for set-level 
mathematics and it is easier.
</p>
</div>

<div id="outline-container-org2c268b0" class="outline-4">
<h4 id="org2c268b0"><span class="section-number-4">10.2.1</span> Strict/weak refl</h4>
<div class="outline-text-4" id="text-10-2-1">
<p>
In ETT we can have two views of refl. NuPRL uses strict sets.
</p>
</div>
</div>

<div id="outline-container-orgf6e026b" class="outline-4">
<h4 id="orgf6e026b"><span class="section-number-4">10.2.2</span> HoTT</h4>
<div class="outline-text-4" id="text-10-2-2">
<p>
ITT + axioms introducing new paths. Examples of new types are the
interval.
</p>

<p>
\[\begin{tikzcd}
I : & \underset{0}\cdot \rar[no head] & \underset{1}\cdot 
\end{tikzcd}\]
</p>

<p>
which is different from boolean types in that it has a nontrivial path
</p>

<p>
\[\begin{tikzcd}
Bool : & \underset{0}\cdot & \underset{1}\cdot 
\end{tikzcd}\]
</p>

<p>
There elements \(0,1 : I\) and \(seg : \mathrm{Id}_I(0,1)\). The booleans have a mapping
out property where a function \(f : Bool \to A\) is defined by
</p>

<ul class="org-ul">
<li>\(f(0) : A\)</li>
<li>\(f(1) :A\)</li>
</ul>

<p>
on intervals, to create a function \(f : I \to A\), you must also specify what the
function does on the segment
</p>

<ul class="org-ul">
<li>\(f(\mathtt{seg}) : f(0) = f(1)\)</li>
</ul>

<p>
just intuitively, we want some free structure on the data defining the type,
so that if we want to map out a type, we are required to define how to get
from a type to another on all constructors. \(f : I \to A\), for example, picks
a path in \(A\).
</p>
</div>
</div>
</div>
<div id="outline-container-org26aebed" class="outline-3">
<h3 id="org26aebed"><span class="section-number-3">10.3</span> How does J deal with new paths?</h3>
<div class="outline-text-3" id="text-10-3">
<p>
Where do you get off adding axioms to type theory? In type theory, 
we have introductions, eliminations, and the Gentzen's inversion/unicity
principle gives us computation by beta rules. Everything has a beta-normal
form.
</p>

<p>
But when we add axioms, we get into trouble. What should we do on these cases
</p>

<ul class="org-ul">
<li>\(J[\ ](\mathtt{seg}, x.Q) \equiv ?\)</li>
<li>\(J[\ ](\lambda x.p, y.Q) \equiv ?\)</li>
</ul>

<p>
the principal problem with HoTT is how to recover constructivity/computation on
HoTT. We can here express non set-level math. If every equalities are decidable,
we have to be working with sets.
</p>
</div>
</div>

<div id="outline-container-org6e75bdb" class="outline-3">
<h3 id="org6e75bdb"><span class="section-number-3">10.4</span> I. types are infinite-groupoids</h3>
<div class="outline-text-3" id="text-10-4">
<p>
Types are \(\infty\text{-groupoids}\). 
</p>

<p>
Recall that \(id_A(M) := \mathtt{refl}_A(M) : Id_A(M,M)\) and that
\(p: Id_A(M,N) \vdash p^{-1} : Id_A(N,M)\) was defined by \(J\). We also
had composition of paths (transitivity). <code>trans(p,q)</code> is defined
by \(J\); so we have an equivalence relation.
</p>

<p>
We have to write code to prove that this is, in fact, an equivalence
relation. Those paths follow the groupoid laws.
</p>
</div>

<div id="outline-container-orgcd55577" class="outline-4">
<h4 id="orgcd55577"><span class="section-number-4">10.4.1</span> Groupoid laws</h4>
<div class="outline-text-4" id="text-10-4-1">
<p>
In a groupoid, these laws has to be satisfied
</p>

<ul class="org-ul">
<li>\(p \cdot p^{-1} \equiv \mathrm{id}\), could be an option, but we usually will accept
equality on a weaker sense \(p \cdot p^{-1} =_{\mathrm{Id}_A(M,N)} \mathrm{id}\).</li>
</ul>

<p>
So we would have elements giving us
</p>

<ul class="org-ul">
<li>\(\mathtt{unitr} : Id_{Id_A(M,N)}(pp^{-1}, \mathrm{id}(M))\)</li>
<li>\(\mathtt{unitl} : p^{-1}p = \mathrm{id}(N)\)</li>
<li>\(\mathrm{idr} : p \cdot \mathrm{id}(N) = p\)</li>
<li>\(\mathrm{idl} : \mathrm{id}(M) \cdot p = p\)</li>
</ul>

<p>
And associativity
</p>

<ul class="org-ul">
<li>\(\mathtt{assoc} : (p \cdot q) \cdot r = p \cdot ( q \cdot r)\)</li>
</ul>

<p>
All of those paths are definible from \(J\), they are implicit on the
structure of types and they are called higher-coherences. If we consider only
paths from \(M\) to \(M\), we would get a higher-group.
</p>
</div>
</div>

<div id="outline-container-orgf531a03" class="outline-4">
<h4 id="orgf531a03"><span class="section-number-4">10.4.2</span> Defining groupoid laws from J</h4>
<div class="outline-text-4" id="text-10-4-2">
<p>
The groupoid laws can be proven from J.
</p>
</div>
</div>
</div>

<div id="outline-container-org7c42525" class="outline-3">
<h3 id="org7c42525"><span class="section-number-3">10.5</span> II. Maps are functors</h3>
<div class="outline-text-3" id="text-10-5">
<p>
If \(f : A \to B\) and \(p: M = M'\), we get \(\mathrm{ap}_f(p) : fM = fM'\). 
That is the principle of equality functionality. This is written using
\(J\) again. We know that \(\mathrm{ap}(\mathtt{refl}(M)) \equiv \mathtt{refl}(f(M))\). \(\mathtt{ap}\) preserves
identities in this sense. Does it preserve all the groupoid structure?
</p>

<p>
We can prove that \(\mathtt{ap}\) preserves all the structure, it gives us a principle
of <b>equality functoriality</b>; it is functorial.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf5a0055" class="outline-2">
<h2 id="orgf5a0055"><span class="section-number-2">11</span> Lecture 11: Functoriality</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-org7714fb6" class="outline-3">
<h3 id="org7714fb6"><span class="section-number-3">11.1</span> Last week</h3>
<div class="outline-text-3" id="text-11-1">
<p>
It is a generalization of the structure given by the equivalence
relation on paths. Path satisfy the groupoid laws with the
concatenation of paths. The data associated to every path can be
thought as a higher dimensional path.
</p>

<p>
For \(f : A \to B\), we have
</p>

<p>
\[ \mathtt{ap}_f : Id(M,N) \to Id(fM, fN)
\]
</p>

<p>
and it is a functorial application, respecting the groupoid structure
due to the eta-rules for \(J\) as
</p>

<ul class="org-ul">
<li>\(ap(id) = id\)</li>
<li>\(ap(p^{-1}) = ap(p)^{-1}\)</li>
<li>\(ap(p\cdot q) = ap(p) \cdot ap(q)\)</li>
</ul>

<p>
and having also that \(ap_{id} = id\) and \(ap_{f \circ g} = ap_g \circ ap_f\). Suppose \(f : \prod_{x{:}A}B_x\),
we would like to have the path
</p>

<p>
\[ Id_A(M,N) \to Id_B(fM,fN)
\]
</p>

<p>
but \(fM : [M/x]B\) and \(fN:[N/x]B\) are not of the same type! But we could use
the transport property to get \(p_{\ast} : [M/x]B \to [N/x]B\). If we apply the transport
property to the inversed path, we get the inverted path \(B[N] \to B[M]\). We would
get different proofs of the lemma if we use \(p_{\ast}\) or \(p_{\ast}^{-1}\).
</p>
</div>
</div>

<div id="outline-container-org160bfd0" class="outline-3">
<h3 id="org160bfd0"><span class="section-number-3">11.2</span> Path-over-path</h3>
<div class="outline-text-3" id="text-11-2">
<p>
The lemma we want to do is
</p>

<p>
\[
M =_A N \longrightarrow f(M) =_p^{x:B_{x}} f(N)
\]
</p>

<p>
this is a notation that says that \(f(M)\) and \(f(N)\) are correlated by
\(p\) on the fiber \(x:B_x\). We will be able to send \(p\) to a
path-over-path \(q : f(M) =_p^{x:B_x} f(N)\).
</p>

<div class="definition">
<p>
Given \(x : A \vdash B : {\cal U}_x\) and \(p : M =_A N\),
</p>

<p>
\[
\Big(Q =_p^{x:B} R \Big)
:=
\Big(p_{\ast} Q =_{[N/x]B} R\Big)
\]
</p>

</div>

<p>
It is possible to prove a lot of lemmas about this type. We can
state reflexivity, symmetry properties and so on.
</p>
</div>
</div>
<div id="outline-container-org73c1866" class="outline-3">
<h3 id="org73c1866"><span class="section-number-3">11.3</span> Equivalence of types: motivation</h3>
<div class="outline-text-3" id="text-11-3">
<p>
Equivalence vs definitional and propositional equality of types as
elements of the universe.
</p>

<ul class="org-ul">
<li>In an informal treatment of classical logic, we mix \(\iff\) and \(=\).
Nothing can distinghish between them. In classical logic there are
only two propositions, so it is difficult to distingish.</li>
<li>Equality should be the relationship respected by everything inside
the language.</li>
<li>But when we are working on a proof relevance setting, there could
be many different proofs of two propositions, and two implications
do not have to be inverses!</li>
<li>Isomorphisms of sets work on a similar way. It is not important to
distinghish between two isomorphic sets given any isomorphism \(f,f^{-1}\).</li>
</ul>

<p>
We could write bijections like \(\omega = \omega^2\), but there are
contexts where we want to make a difference between the two. Set theory
allows us to ask nonsensical things like \(0 \in 1\).
</p>

<p>
The condition of bijection on types can be translated as a function
\(f : A \to B\) with a \(g : B \to A\) such that
</p>

<p>
In ITT, let's suppose a set of functions \(N \to N\) and a non-trivial 
bijection to itself.
</p>

<ul class="org-ul">
<li>\(F(f) = f'\) and \(G(f') = f\)</li>
<li>\(F(g) = g'\) and \(G(g') = g\)</li>
</ul>

<p>
but what do those equalities mean? 
</p>

<ul class="org-ul">
<li>\(F(f)(x) = f'(x)\) and \(G(f)(y) = f(y)\) would be an interpretation.
Those would be extensionally equal, but different functions.</li>
</ul>

<p>
The notion of bijection is not very useful when working on higher-order
types.
</p>
</div>
</div>
<div id="outline-container-org5f0a170" class="outline-3">
<h3 id="org5f0a170"><span class="section-number-3">11.4</span> Equivalence on types involving a universe</h3>
<div class="outline-text-3" id="text-11-4">
<p>
The elements of \({\cal U}\) have structure, each one of them is a groupoid.
The idea of bijection \(FG(A) = A\) is not workable; we are interested
in nontrivial isomorphisms, in an equivalence rather than equality
\(FG(A) \simeq A\).
</p>

<p>
This is similar to isomorphisms and equivalence of categories. We want
\(FG(A) \cong A\), we do not need \(FG(A) = A\). Equivalence is isomorphism up
to isomorphism.
</p>

<p>
And when we have a universe of universes, the same question repeats
itself. We need another level of comparison now. We would get the
higher-group structure of a type.
</p>

<p>
Isomorphism here is not a proposition but a structure.
</p>
</div>
</div>
<div id="outline-container-org9118004" class="outline-3">
<h3 id="org9118004"><span class="section-number-3">11.5</span> Equivalence</h3>
<div class="outline-text-3" id="text-11-5">
<p>
Given \(f : A \to B\), a quasiinverse of \(f\) is given by
\((g,\alpha,\beta)\) such that
</p>

<ul class="org-ul">
<li>\(g : B \to A\)</li>
<li>\(\alpha : \prod_{a:A} g(f(a)) =_A a\)</li>
<li>\(\beta : \prod_{b:B} f(g(b)) =_B b\)</li>
</ul>

<p>
The type of <b>quasiinverses</b> is
</p>

<p>
\[
QI(f)_{A\to B} := \sum_{g : B \to A} 
\left(
\left(\prod_{a:A} g(f(a)) = a\right)
\times
\left(\prod_{b:B} f(g(b)) = b\right)
\right)
\]
</p>
</div>

<div id="outline-container-orgfa43e37" class="outline-4">
<h4 id="orgfa43e37"><span class="section-number-4">11.5.1</span> Another version</h4>
<div class="outline-text-4" id="text-11-5-1">
<p>
In ITT, this is different from
</p>

<ul class="org-ul">
<li>\(\alpha' : g \circ f = id_A\)</li>
<li>\(\beta' : f \circ g = id_B\)</li>
</ul>

<p>
this uses two paths instead of two homotopies.
Function extensionality is now
</p>

<p>
\[
(f =_{A \to B} g) \simeq
\left( \prod_{a:A}f(a)=_B g(a) \right)
\]
</p>

<p>
saying that every homotopy defines an equation. Those
two types of proofs are equivalent.
</p>
</div>
</div>
</div>

<div id="outline-container-orge65055d" class="outline-3">
<h3 id="orge65055d"><span class="section-number-3">11.6</span> Univalence axiom</h3>
<div class="outline-text-3" id="text-11-6">
<p>
There is an equivalence between equivalence and equality.
</p>

<p>
\[
(A \simeq B) \simeq (A = B)
\]
</p>

<p>
Equivalences are given by
</p>

<p>
\[
\sum_{f : A \to B} \sum_{g : B \to A} 
\left( f \circ g = id_B \times g \circ f = id_A \right)  \times \text{ some coherence condition }
\]
</p>

<p>
to avoid the function extensionality issue, we can write
homotopies instead
</p>

<p>
\[
\sum_{f : A \to B} \sum_{g : B \to A} 
\left( f \circ g \sim id_B \times g \circ f \sim id_A \right) \times \text{ some coherence condition }
\]
</p>

<p>
but we are going to have function extensionality.
</p>
</div>
</div>
</div>
<div id="outline-container-orgfad7674" class="outline-2">
<h2 id="orgfad7674"><span class="section-number-2">12</span> Lecture 12: Equivalence of Types</h2>
<div class="outline-text-2" id="text-12">
</div><div id="outline-container-org6fcc8c4" class="outline-3">
<h3 id="org6fcc8c4"><span class="section-number-3">12.1</span> Equivalence of types</h3>
<div class="outline-text-3" id="text-12-1">
<p>
We write the equivalence of \(A \simeq B\). We say that \(f : A \to B\) 
is an <b>equivalence</b> if there exists
</p>

<p>
\[
\left( \sum_{g:B\to A} f \circ g \sim id_B \right) \times
\left( \sum_{h:B\to A} h \circ f \sim id_A \right)
\]
</p>

<p>
the type of equivalences is
</p>

<p>
\[
A \simeq B := \sum_{f:A\to B} \mathrm{isequiv}(f)
\]
</p>
</div>
</div>

<div id="outline-container-org644fe99" class="outline-3">
<h3 id="org644fe99"><span class="section-number-3">12.2</span> Elements of the equivalence</h3>
<div class="outline-text-3" id="text-12-2">
<p>
An equivalence is defined whenever those functions
exist
</p>

<ol class="org-ol">
<li>\(f : A \to B\)</li>
<li>\(g:B\to A\)</li>
<li>\(\alpha: \prod_{y:B} f(g(y)) =_B y\)</li>
<li>\(h : B\to A\)</li>
<li>\(\beta : \prod_{x:A} h(f(x)) =_A x\)</li>
</ol>
</div>
</div>

<div id="outline-container-orgf78b97c" class="outline-3">
<h3 id="orgf78b97c"><span class="section-number-3">12.3</span> Quasiinverse</h3>
<div class="outline-text-3" id="text-12-3">
<p>
Quasiinverses are defined as
</p>

<p>
\[ \mathrm{quasiinverse}(f) :=
\sum_{g:B\to A} f\circ g \sim id_B \times g \circ f \sim id_{A}
\]
</p>

<p>
There are three important properties
</p>

<ol class="org-ol">
<li>\(qinv(f) \to isequiv(f)\)</li>
<li>\(isequiv(f) \to qinv(f)\)</li>
<li>\(isequiv(f)\) expresses an HPROP, it has at most one proof up
to higher homotopy.</li>
</ol>

<p>
we can transform the data from a quasiinverse to a equivalence.
from  \(H : f \sim_{A \to B} g\) we get \(\prod_{x:A} Id_B(f x, gx)\). \(H\) is functorial in
\(x:A\); in the sense that this diagram commutes for any \(p : a = a'\)
</p>

<p>
\[\begin{tikzcd}
f(a)\rar[no head]{H(a)} \dar[swap,no head]{ap_f(p)} & g(a) \dar[no head]{ap_g(p)} \\
f(a')\rar[no head]{H(a')} & g(a')
\end{tikzcd}\]
</p>

<p>
Homotopy is natural (or <i>polymorphic</i>) in \(x\).
</p>
</div>
</div>

<div id="outline-container-org3ad3258" class="outline-3">
<h3 id="org3ad3258"><span class="section-number-3">12.4</span> Funtion extensionality</h3>
<div class="outline-text-3" id="text-12-4">
<ol class="org-ol">
<li>definable if \(\mathtt{happly}: f =_{A \to B} g \to f \sim g\).</li>
<li>the axiom of funtion extensionality says that the
above map is an equivalence.</li>
</ol>

<p>
In the presence of function extensionality, we could write \(\alpha\)
and \(\beta\) as \(f \circ g \sim id\) and \(h \circ f \sim id\). Once you
have function extensionality, you can write the homotopy as
an equality
</p>

<ul class="org-ul">
<li>\(\prod_{y:B} f(g(y)) = y\)</li>
<li>by definition of homotopy, \(f\circ g \sim id\)</li>
<li>by function extensionality, \(f \circ g = id_{B}\)</li>
</ul>
</div>
</div>

<div id="outline-container-org8a56062" class="outline-3">
<h3 id="org8a56062"><span class="section-number-3">12.5</span> Exercises</h3>
<div class="outline-text-3" id="text-12-5">
<ol class="org-ol">
<li>\(id : A \to A\) is an equivalence, give the four parts of the
equivalence.</li>
<li>if \(f\) is an equivalence, \(f^{-1}\), given by the quasiinverse, is
an equivalence.</li>
<li>if \(f\) and \(g\) are equivalences, then so is \(g \circ f: A \to C\).</li>
</ol>
</div>
</div>

<div id="outline-container-org85915eb" class="outline-3">
<h3 id="org85915eb"><span class="section-number-3">12.6</span> Structure of paths in types</h3>
<div class="outline-text-3" id="text-12-6">
<p>
For example, if we take \(Id_{A \times B}(-,-)\), the identity type seems invariant
to the way the type has been constructed; but a structure can be deduced
from the types.
</p>

<p>
There is a function \(f\) with the type \(Id_{A \times B}(x,y) \to Id_A(\pi_1x, \pi_2y) \times Id_B( \pi_2x, \pi_2y)\)
that we can define as
</p>

<p>
\[
f := \lambda p. \left\langle \mathrm{ap}_{\pi_1}(p), \mathrm{ap}_{\pi_2}(p) \right\rangle
\]
</p>

<p>
And we can prove that \(f\) is an equivalence
</p>

<p>
\[
Id_A(x,y) \simeq Id_A(\pi_1x,\pi_1y) \times Id_B(\pi_2x, \pi_2y)
\]
</p>

<p>
because it suffices to exhibit a quasiinverse for \(f\).
</p>

<ul class="org-ul">
<li>\(g : Id_A(\pi_1x,\pi_1y) \times Id_B(\pi_2x,\pi_2y) \to Id_{A \times B}(x,y)\)</li>
<li>\(\alpha : g(f(p)) =_{Id_{A\times B}(x,y)} p\)</li>
<li>\(\beta : f(g(q)) =_{Id_A(-,-) \times Id_B(-,-)} q\)</li>
</ul>

<p>
we use pattern matching
</p>

<p>
\[
g := \lambda (p,q). ap^2_{pair}\ p\ q
\]
</p>

<p>
where \(pair = \lambda x,y. (x,y)\), and \(ap^2_f\ p\ q : Id(f x y, f x' y')\) where
\(p: Id(x,x')\) and \(q : Id(y,y')\).
</p>
</div>
</div>
<div id="outline-container-org726ccdc" class="outline-3">
<h3 id="org726ccdc"><span class="section-number-3">12.7</span> Products</h3>
<div class="outline-text-3" id="text-12-7">
<p>
We need to show the following for the quasi-inverse
</p>

<ul class="org-ul">
<li>\(\eta :\prod_p (ap^2_{pair} \left(ap_{\pi_1}(p), ap_{\pi_2}(p)) = p\right)\)</li>
<li>\(\beta_1 : \prod_p\prod_q ap_{\pi_1}(ap^2_{pair}\ p\ q) = p\)</li>
<li>\(\beta_2 : \prod_p\prod_q ap_{\pi_2}(ap^2_{pair}\ p\ q) = p\)</li>
</ul>

<p>
We need by path induction \(x : A \times B \vdash - : ap^2_{pair}\ (ap_{\pi_1}(refl(x))\ ap_{\pi_2}(refl(x)) = refl(x)\)
</p>

<ul class="org-ul">
<li>\(ap_{\pi_1}(refl(x)) \equiv refl(\pi_1(x))\)</li>
<li>\(ap_{\pi_2}(refl(x)) \equiv refl(\pi_2(x))\)</li>
</ul>

<p>
Note that the type checking will depend on the computation rules, and
this is antimodular. If you change anything on the code, everything that
relies on it could break.
</p>

<ul class="org-ul">
<li>\(ap^2_{pair}\ (refl(\pi_1 x))\ (refl(\pi_2 x)) \equiv refl(\pi_1(x),\pi_2(x)) \equiv refl(x)\)</li>
</ul>
</div>
</div>
<div id="outline-container-org5e376d8" class="outline-3">
<h3 id="org5e376d8"><span class="section-number-3">12.8</span> Nullary case</h3>
<div class="outline-text-3" id="text-12-8">
<p>
\[
Id_{1}(x,y) \simeq 1
\]
</p>
</div>
</div>

<div id="outline-container-orgd6e36ab" class="outline-3">
<h3 id="orgd6e36ab"><span class="section-number-3">12.9</span> Coproducts</h3>
<div class="outline-text-3" id="text-12-9">
<p>
In coproducts, we would like to prove that
</p>

<ul class="org-ul">
<li>\(Id_{A+B}(inl(a),inl(a')) \simeq Id_A(a,a')\)</li>
<li>\(Id_{A+B}(inr(b),inr(b')) \simeq Id_B(b,b')\)</li>
<li>\(Id_{A+B}(inl(a),inr(b)) \simeq 0\)</li>
<li>\(Id_{A+B}(inr(b),inl(a)) \simeq 0\)</li>
</ul>

<p>
If we were to find a map from
</p>

<ul class="org-ul">
<li>\(x : Id_{A+B}(inl(a),inl(a')) \vdash -:Id_A(a,a')\)</li>
</ul>

<p>
using path induction on \(p\), we would have to find a motive \(C = ?\)
and the conclusion should be \(C(inl(a),inl(a'), p)\), where \(J[C](p,\dots)\)
would be the induction on paths. But how do we get rid of the \(inl\)?
We should define a motive as
</p>

<p>
\[
D(u,v) = Id_{A}(outl(u), outl(u))
\]
</p>

<p>
but there are not \(outl\) functions! We want the motive to be
</p>

<p>
\[
F : (A+B) \times (A+B) \to {\cal U}
\]
</p>

<p>
such that
</p>

<ul class="org-ul">
<li>\(F(inl(a),inl(a')) \equiv Id_A(a,a')\)</li>
<li>\(F(inr(b),inl(b')) \equiv Id_A(b,b')\)</li>
<li>\(F(inl(-),inr(-)) \equiv 0\)</li>
<li>\(F(inr(-),inr(-)) \equiv 0\)</li>
</ul>

<p>
Exercise: define such an \(F\) by double induction.
</p>

<p>
The critical lemma is \(x : A+B \vdash -:F(x,x)\), which we need to
use path induction.
</p>

<p>
\[ \mathtt{case}[z.F(z,z)](x; m:A. refl(m) ; n:B. refl(n) ) : F(x,x)
\]
</p>

<p>
where \([inl(m)/z]F(z,z) \equiv F(inl(n),inl(n))\).
</p>
</div>
</div>
</div>
<div id="outline-container-org60a5939" class="outline-2">
<h2 id="org60a5939"><span class="section-number-2">13</span> Lecture 13: Path structure of Types</h2>
<div class="outline-text-2" id="text-13">
</div><div id="outline-container-orgc058e3e" class="outline-3">
<h3 id="orgc058e3e"><span class="section-number-3">13.1</span> Last week</h3>
<div class="outline-text-3" id="text-13-1">
<p>
We characterized paths in coproducts.
</p>
</div>

<div id="outline-container-orge42cc23" class="outline-4">
<h4 id="orge42cc23"><span class="section-number-4">13.1.1</span> Lemma</h4>
<div class="outline-text-4" id="text-13-1-1">
<p>
\(x : A +B \vdash -:F(x,x)\)
</p>

<p>
we use induction on \(x\)
</p>

<ul class="org-ul">
<li>\(a:A \vdash refl(a) : F(inl(a),inl(a))\)</li>
<li>\(b:B \vdash refl(b) : F(inr(b),inr(b))\)</li>
</ul>

<p>
what we want to define a quasiinverse 
</p>

<p>
\[
f : \prod_{x,x' : A+B} Id_A(x,x') \to F(x,x')
\]
</p>

\begin{aligned}
f := \lambda x. \lambda x'. \mathtt{case}(x;\ a:A.\ \mathtt{case}( & \\
& x'; a':A. \lambda p:Id_A(inl(a),inl(a')) . J[F](p; z.F(z,z), \\
& \dots )
\end{aligned}
</div>
</div>

<div id="outline-container-orge118aa0" class="outline-4">
<h4 id="orge118aa0"><span class="section-number-4">13.1.2</span> Quasiinverse</h4>
<div class="outline-text-4" id="text-13-1-2">
<p>
Now we have to define
</p>

<p>
\[
g : \prod_{x,x':A+B} F(x,x') \to Id_{A+B}(x,x')
\]
</p>

<p>
as
</p>

<p>
\[
g := \lambda x,x',z:F(x,x')\ \text{cases on }\ x\ x'
\]
</p>

<p>
and now we want to show
</p>

<ul class="org-ul">
<li>\(z:F(x,x') \vdash \alpha(z) : f(g(z)) = z\)</li>
<li>\(z:Id_{A+B}(x,x') \vdash \beta(z) : g(f(z)) = z\)</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org3102202" class="outline-3">
<h3 id="org3102202"><span class="section-number-3">13.2</span> Positive types</h3>
<div class="outline-text-3" id="text-13-2">
<p>
We work with coproducts as examples of positive types. We will
characterize \(Id_0(-,-)\) and the path structure of \(\mathbb{S}^1\).
</p>

<p>
\[
Id_{s'}(b,b) = \Omega_b(S') \simeq \mathbb{Z}
\]
</p>

<p>
We are doing synthetic homotopy theory.
</p>
</div>
</div>

<div id="outline-container-orgf7ae369" class="outline-3">
<h3 id="orgf7ae369"><span class="section-number-3">13.3</span> Characterizing paths on identity types</h3>
<div class="outline-text-3" id="text-13-3">
<p>
Given a type \(A\), we consider \(Id_{Id_{\dots_A}}(-,-)\). We cannot say much, because
it includes as special cases the spheres \(\Omega(S^n)\).
</p>

<p>
If \(f : A \to B\) is an equivalence, then so is \(ap_f : a =_A a' \to f(a) = f(a')\).
What we have is \(f : A \to B\), so \(\alpha : \prod_{a:A}f^{-1}(f(a)) =_A a\) and \(\beta : \prod_{b:B}f^{-1}(f(b)) =_B b\).
because it has quasiinverses. To prove this, we define
</p>

<p>
\[ ap^{-1}_f := \alpha(a)^{-1} \cdot ap_{f^{-1}} \cdot \alpha(a')
\]
</p>

<p>
now we need
</p>

<ul class="org-ul">
<li>\(\alpha' : \prod_{p:a =_A a'} ap^{-1}_f(ap_f(p)) =_{a = a'} p\)</li>
<li>\(\beta' : \prod_{q:f(a) =_B f(a')} ap_f(ap_{f}^{-1}(q)) =_{f(a) = f(a')} q\)</li>
</ul>

<p>
and both can be proved by path induction.
</p>
</div>
</div>
<div id="outline-container-orgee1864f" class="outline-3">
<h3 id="orgee1864f"><span class="section-number-3">13.4</span> Identity types are homs in an (infinite,1)-category</h3>
<div class="outline-text-3" id="text-13-4">
<p>
The type \(Id_A(x,y)\) is similar to \(Hom_A(x,y)\). \(Id_A(-,-)\) is a family
of types, and hence a fibration.
</p>

<p>
We look at the transport/fibration properties taking
the notation \(E(x,y) := Id(x,y)\)
</p>

<ol class="org-ol">
<li><p>
fix \(x_{0}:A\), consider \(\lambda y:A.E(x_0,y)\),
</p>

<p>
\[
     tr[y.E(x_0,y)](q) : E(x_0,y) \to E[x_0,y']
     \]
</p>

<p>
it maps \(p:E(x_0,y) \mapsto p \cdot q\)
</p></li>

<li><p>
fix \(y_0 : A\), consider \(x . E(x,y_0)\),
</p>

<p>
\[
     tr[x.E(x,y_0)](p) : E(x,y_0) \to E(x',y_0)
     \]
</p>

<p>
mapping \(q \mapsto p^{-1}\cdot q\).
</p></li>

<li>for \(p : x = x'\), \(q : E(x,x)\); \(tr[x.E(x,x)](p) : q \mapsto p^{-1} \cdot q \cdot p\).</li>
</ol>

<p>
It can be checked by path induction. This show that they behave like
Hom's and that they exhibit the infinity-groupoid structure.
</p>
</div>
</div>
<div id="outline-container-orgd445de6" class="outline-3">
<h3 id="orgd445de6"><span class="section-number-3">13.5</span> Recall: identity elimination rule</h3>
<div class="outline-text-3" id="text-13-5">
<p>
The idea is that, in ITT, this can be thought of as an induction
principle arising from taking the Id to be the least reflexive
relation, because the only introduction rule says so; and the 
elimination works as that.
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash p:Id_A(M,N)$}
\noLine
\UnaryInfC{$\Gamma,x:A,y:A,z:Id(x,y) \vdash F : {\cal U}$}
\AxiomC{$\Gamma, x:A \vdash q : F(x,x,refl) $}
\BinaryInfC{$\Gamma \vdash J[F](p,x.q) : F(M,N,p)$}
\end{prooftree}

<p>
For doing set-level mathematics, this works. In HoTT, we interpret the
identities as paths in \(A\), not as inductive types. We conclude things
about non-trivial paths only reasoning about reflexivity!
</p>
</div>
</div>
</div>
<div id="outline-container-org18a2d4a" class="outline-2">
<h2 id="org18a2d4a"><span class="section-number-2">14</span> Lecture 14: Identity elimination</h2>
<div class="outline-text-2" id="text-14">
</div><div id="outline-container-orge631eab" class="outline-3">
<h3 id="orge631eab"><span class="section-number-3">14.1</span> Last week exercise</h3>
<div class="outline-text-3" id="text-14-1">
<p>
If $ - : qinv(f)$, then \(-: ap_f\).
</p>

<ol class="org-ol">
<li>\(ap_f^{-1} = ap_{f^{-1}}\)</li>
<li>\(\alpha : \prod_{p : a=_A a'} \dots\)</li>
<li>\(\beta : \prod_{q : f(a) = (a')} ap_f(\alpha(a)^{-1} \cdot ap_{f^{-1}}(Q) \cdot \alpha(a')) = q\)</li>
</ol>

<p>
the (2) is proved by path induction, but (3) is not so easy. If we use
path induction there, we will get \(F[f(a),f(a'),q]\) as motive, which should
be then \(ap_f(\alpha(a)^{-1} \cdot ap_{f^{-1}}(Q) \cdot \alpha(a')) = q\). Recall that, for coproducts,
</p>

<ul class="org-ul">
<li>\(F[inl(a),inl(a')] \equiv (a = a')\)</li>
</ul>

<p>
but here, we cannot do that, we would need to define it such that
\(F[f(a),f(a'),q] =_{{\cal U}} \left(ap_f(\alpha(a)^{-1} \cdot ap_{f^{-1}}(Q) \cdot \alpha(a')) = q\right)\). If \(M:A\) and
\(p : A =_{{\cal U}} A'\), then \(p_{\ast}(M) : A'\). So you use the fact that
</p>

<ul class="org-ul">
<li>\(f^{-1}(f(a)) =_A a\), and</li>
<li>\((f^{-1},\alpha,\beta) : qinv(f)\).</li>
</ul>
</div>
</div>
<div id="outline-container-org8cf84ff" class="outline-3">
<h3 id="org8cf84ff"><span class="section-number-3">14.2</span> Justifying the J operator</h3>
<div class="outline-text-3" id="text-14-2">
<p>
The J operator has different meanings in ITT and HoTT
</p>

<ol class="org-ol">
<li>In ITT, J expresses an induction principle on proofs of identity,
of which there is exactly one.</li>

<li><p>
In HoTT (or ITT + FUNEXT), the situation is less clear,
</p>

<p>
\[J[\ ](refl(M), x.Q) \equiv [M/x]Q\]
</p>

<p>
but then, we have the problem
</p>

<p>
\[J[\ ](funext(H); x.Q) \equiv ?
    \]
</p>

<p>
where the Gentzen's principle does not hold. How should apply
\(J\) with the Univalence Axiom or to other defined equalities?
</p>

<ul class="org-ul">
<li>\(J[\ ](UA(E), x.id) \equiv ?\)</li>
<li>\(J[\ ](seg, x.id) \equiv ?\)</li>
<li>\(J[\ ](loop, x.id) \equiv ?\)</li>
</ul></li>

<li>In ETT, it does not work like this. Equality reflection allows us
to replace to equalities; we do not need J at all. We get FUNEXT
without special arrangement. It has a computational interpretation.
You end using a theory of realizability.</li>

<li>In OTT, we can have FUNEXT without special arrangement. It has a
computational interpretation.</li>
</ol>

<p>
In HoTT, we give up on computation; but maybe we can recover one. We
justify the theory by interpretation into the classical ZF using
simplicial sets.
</p>
</div>
</div>
<div id="outline-container-orga6d6346" class="outline-3">
<h3 id="orga6d6346"><span class="section-number-3">14.3</span> Solving (partially) the problem</h3>
<div class="outline-text-3" id="text-14-3">
<p>
Idea: have \(x:A \vdash Q : C[x,x,refl(x)]\) where the motif
\(x:A,y:A,z: x=y \vdash C : {\cal U}\). We want to get \(- : C[M,N,P]\) 
where \(M,M':A,P: M=M'\). This is what the J-rule is saying. 
</p>

<p>
We know that \([M/x]Q : C[M,M,refl(M)\), and \(Q\) depends functorially
on \(x\). The logic in HoTT is integrated with the whole structure of
maps. There is a continuous dependency from \(Q\) to \(A\). So we also
know that \([P/x]Q : [M/x]Q =_p^{C(-,-,refl(-))} [N/x]Q\) (in an abuse of language)
and $ - : p<sub>&lowast;</sub> [M/x]Q =<sub>C(M',M',refl(M'))</sub> [M'/x]Q$.
</p>

<p>
Since $refl(M) : M = M and \(p : M = M'\), now it suffices to find
\(\alpha : refl(M) =^{Id(-,-)}_{(refl(M),p)} p\), wich is to say that
</p>

<p>
\[
\alpha : \left\langle refl(M),p \right\rangle(refl(M)) = p
\]
</p>

<p>
the triple \((refl,p,\alpha)\) would take \(C(M,M,refl(M))\) into \(C(M,M',p)\).
</p>

<p>
\[ tr[x.Id(x,x)](p)(q) = p^{-1}\cdot q \cdot p\]
</p>

<p>
it works choosing \(refl_{Id_{A}(M,M')}(p)\). \(C\) does the work! A priori, \(C\) respects
whatever it is that \(Id\) internalizes!
</p>
</div>
</div>

<div id="outline-container-org576fad9" class="outline-3">
<h3 id="org576fad9"><span class="section-number-3">14.4</span> The identity type</h3>
<div class="outline-text-3" id="text-14-4">
<p>
The equality is respected by all the theory, that is why the identity
type has those special properties. In HoTT, \(Id\) internalizes homotopy
equivalence, and, by univalence, everything respects homotopy
equivalence. In contrast, in ITT, \(Id\) internalizes definitional
equality.
</p>

<p>
The identity type does not define homotopy equivalence, it only 
internalizes the notion.
</p>
</div>
</div>
<div id="outline-container-org2bcb891" class="outline-3">
<h3 id="org2bcb891"><span class="section-number-3">14.5</span> Homotopy types</h3>
<div class="outline-text-3" id="text-14-5">
<p>
The slogan is that Homotopy (Type Theory) is (Homotopy Type) Theory.
</p>

<div class="definition">
<p>
A type \(A\) is a <b>set</b>, aka 0-type, iff for all \(p,q : x =_{A} y\), we have
that \(p=q\).
</p>

</div>

<p>
\[ \mathrm{isSet}(A) :=
\prod_{x,y:A}\prod_{p,q: x=y} p = q
\]
</p>

<p>
it is a discrete groupoid up to higher homotopy. The only paths are
the reflexivities, but up to higher-homotopy! There can be other loops,
but they are homotopic to the reflexivity.
</p>

<p>
You can form a type theory there every type is a set.
</p>
</div>
</div>
</div>
<div id="outline-container-org35d4b13" class="outline-2">
<h2 id="org35d4b13"><span class="section-number-2">15</span> Lecture 15: Sets and propositions</h2>
<div class="outline-text-2" id="text-15">
</div><div id="outline-container-orgfccc6e8" class="outline-3">
<h3 id="orgfccc6e8"><span class="section-number-3">15.1</span> Last week</h3>
<div class="outline-text-3" id="text-15-1">
<p>
We saw a justification for the J-rule and the interaction with
the functioriality of \(C\) and the inductive analysis of J.
</p>
</div>
</div>

<div id="outline-container-orgf5ccb6b" class="outline-3">
<h3 id="orgf5ccb6b"><span class="section-number-3">15.2</span> The Interval Type</h3>
<div class="outline-text-3" id="text-15-2">
<p>
Formation rule
</p>

\begin{prooftree}
\RightLabel{$(I-F)$}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash I : {\cal U}$}
\end{prooftree}

<p>
Introduction rules
</p>

\begin{prooftree}
\RightLabel{(iI0)}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash  0 : I$}
\RightLabel{(iI1)}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash  1 : I$}
\noLine
\BinaryInfC{}
\end{prooftree}

<p>
And another introduction rule
</p>

\begin{prooftree}
\RightLabel{(iIseg)}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash seg : Id_I(0,1)$}
\end{prooftree}

<p>
This is an inductive definition of the type. The type should be
freely generated by these constructors.
</p>

\begin{prooftree}
\AxiomC{$\Gamma, x:I \vdash C[x] : {\cal U}$}
\AxiomC{$\Gamma \vdash M_0 : C[0]$}
\noLine
\UnaryInfC{$\Gamma \vdash M_1 : C[1]$}
\AxiomC{$\Gamma \vdash p : M_0 =_{seg}^{x:C} M_1$}
\TrinaryInfC{$\Gamma, x:I \vdash \mathrm{rec}_I[x.C](x;M_0,M_1 )  : C[x]$}
\end{prooftree}

<p>
where it is defined as
</p>

<ul class="org-ul">
<li>\(rec[x.C](0;M_0,M_1, -) \equiv M_0 : C[0]\)</li>
<li>\(rec[x.C](1;M_0,M_1, -) \equiv M_1 : C[1]\)</li>
<li>\(dap(\lambda x . rec[x.C](0;M_0,M_1,p)) \equiv p : M_0 =^{x:C}_{seg} M_1\)</li>
</ul>

<p>
the \(dap\) map should be functorial
</p>

<p>
\[ dap : \prod_f \prod_{x:A}B \longrightarrow \prod_{p:Id(x,y)} Id(fx,fy)
\]
</p>
</div>
</div>

<div id="outline-container-orgfa5d0c7" class="outline-3">
<h3 id="orgfa5d0c7"><span class="section-number-3">15.3</span> The total path space of a type</h3>
<div class="outline-text-3" id="text-15-3">
<p>
The total path space are the morphisms from the interval
</p>

<p>
\[
\sum_{x:A}\sum_{y:A} Id(x,y) \simeq (I \to A)
\]
</p>
</div>

<div id="outline-container-orgb2073cc" class="outline-4">
<h4 id="orgb2073cc"><span class="section-number-4">15.3.1</span> Proof</h4>
<div class="outline-text-4" id="text-15-3-1">
<p>
The rec function goes from left to right
</p>

<p>
\(\lambda x,y,p. \lambda t. rec[-:A](t;x,y,p)\)
</p>

<p>
And the description of the path goes the other way
</p>

<p>
\[ \lambda h. (h(0),h(1), ap(seg)).
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org1d859b4" class="outline-3">
<h3 id="org1d859b4"><span class="section-number-3">15.4</span> Conclusion on the total path space</h3>
<div class="outline-text-3" id="text-15-4">
<p>
A path between functions is an homotopy, a path between
every pair of points
</p>

\begin{align*}
\int Id_{A \to B} &
\simeq I \to (A \to B) \\&
\simeq (I \times A) \to B \\&
\simeq (A \times I) \to B \\&
\simeq A \to (I \to B) \\&
\simeq A \to \int Id_{B}
\end{align*}

<p>
Function extensionality says that
</p>

<p>
\[
Id(f,g) \simeq \prod_{x:A}Id_{A \to B}(fx,gx)
\]
</p>

<p>
which can be proved by definition and taking the right-to-left
direction as an axiom.
</p>
</div>
</div>
<div id="outline-container-org54ea02c" class="outline-3">
<h3 id="org54ea02c"><span class="section-number-3">15.5</span> Sets</h3>
<div class="outline-text-3" id="text-15-5">
<p>
A type is a set if it is homotopically discrete.
</p>

<p>
\[
\mathrm{isSet}(A) \equiv \prod_{x,y:A}\prod_{p,q : x=y} p=q
\]
</p>

<p>
up to higher homotopy, the only equality is reflexivity.
Pure ITT is a theory of sets. All of the constructs of ITT
preserve the property of being a set
</p>

<ol class="org-ol">
<li>\(1\) is a set.</li>
<li>if \(A,B\) are sets, \(A \times B\) is a set.</li>
<li>if \(A,B[x:A]\) are sets, \(\sum_{x:A} B\) is a set.</li>
<li>if \(A,B\) are sets, \(A+B\) is a set.</li>
<li>\(Nat\) is a set.</li>
<li>if \(A,B\) are sets, \(A \to B\) is a set.</li>
<li>if \(A,B[x:A]\) are sets, \(\prod_{x:A} B\) is a set.</li>
</ol>

<p>
In the NPS book, they use the terminology <code>Sets</code>.
</p>
</div>
</div>
<div id="outline-container-org7e99488" class="outline-3">
<h3 id="org7e99488"><span class="section-number-3">15.6</span> Problems interpreting ITT as a theory of sets</h3>
<div class="outline-text-3" id="text-15-6">
<p>
Why are the identities sets? Why is the universe a set?
</p>

<p>
ETT is also a set theory, and it is easier to work with it. In
ITT, we have to pay the price of higher dimensionality without
using it.
</p>
</div>
</div>

<div id="outline-container-org3ca556d" class="outline-3">
<h3 id="org3ca556d"><span class="section-number-3">15.7</span> Is universe a set?</h3>
<div class="outline-text-3" id="text-15-7">
<p>
Are the elements of \({\cal U}\) codes (names of types) or types? We can
introduce the elements of \({\cal U}\) inductively. The codes will form a
set.
</p>

<p>
NuPRL and HoTT take the elements to be types; but NPS take the
elements to be codes and to form a set, using ITT as a set theory.
</p>
</div>
</div>
</div>
<div id="outline-container-org84d0280" class="outline-2">
<h2 id="org84d0280"><span class="section-number-2">16</span> Lecture 16: ITT</h2>
<div class="outline-text-2" id="text-16">
<p>
All of the basic constructs of ITT preserve the relation of being a Set.
Up to higher homotopy, there is at most one proof of equality of any two
elements.
</p>

<p>
\({\cal U}\) is rigged to be a set and it is a set of codes; an inductively defined
set.
</p>
</div>

<div id="outline-container-org4223374" class="outline-3">
<h3 id="org4223374"><span class="section-number-3">16.1</span> The identity type is a set</h3>
<div class="outline-text-3" id="text-16-1">
<p>
\(Id_A(x,y)\) is a set if \(A\) is a set
</p>
</div>

<div id="outline-container-org2199633" class="outline-4">
<h4 id="org2199633"><span class="section-number-4">16.1.1</span> Proof</h4>
<div class="outline-text-4" id="text-16-1-1">
<p>
Assume that \(A\) is a set
</p>

<p>
\[
H : \prod_{x,y:A}\prod_{p,q:Id_A(x,y)}Id_{Id_A(x,y)}(p,q)
\]
</p>

<p>
and we want to show that \(Id(x,y)\) is a set. Assume \(u,v : A\),
\(r,s:Id(u,v)\) and \(\alpha,\beta : Id(r,s)\). We have to show that
</p>

<p>
\[
Id_{Id_{Id_A(u,v)}(r,s)}(\alpha,\beta)
\]
</p>

<p>
We specialize \(H' := H(u)(v)(r) : \prod_{q:Id_A(u,v)} Id(r,q)\); and we are going
to exploit the functoriality of \(H'\). So
</p>

<p>
\[ apd_{H'} : \prod_{q,q': Id_A(u,v)} \prod_{\gamma : Id(q,q')} Id(\gamma_{\ast}(H'(q)),H'(q')
\]
</p>

<p>
being a path-over scenario. Here,
</p>

<p>
\[
apd_{H'}(r,s,\alpha) : Id(\alpha_{\ast}(H'(r)), H'(s))
\]
</p>

<p>
and, similarly
</p>

<p>
\[
apd_{H'}(r,s,\beta) : Id(\beta_{\ast}(H'(r)), H'(s)).
\]
</p>

<p>
So, we can conclude that I can get an element of the identity
\(Id(\alpha_{\ast}(H'(r)), \beta_{\ast}(H'(r)))\). What this is telling us is that, by
post-composition given by transport in the identity, \(Id(H'(r)\alpha, H'(r)\beta)\).
</p>

<p>
We have that \(H'(r)\cdot \alpha = H'(r)\cdot \beta\), so I can multiply by the inverses
to get
</p>

<p>
\[
H'(r)^{-1}H'(r)\alpha = H'(r)^{-1}H'(r)\beta
\]
</p>

<p>
and then \(\alpha = \beta\). We have used here the groupoid structure.
</p>
</div>
</div>
</div>
<div id="outline-container-org12d9461" class="outline-3">
<h3 id="org12d9461"><span class="section-number-3">16.2</span> ETT</h3>
<div class="outline-text-3" id="text-16-2">
<p>
ETT is also a set theory because ITT is a set theory. ETT is easier to
use when working with sets than ITT. HoTT adds the univalence axiom
and Higher Inductive Types. Here, homotopy can be thought as a branch
of logic. 
</p>
</div>
</div>

<div id="outline-container-orga5a88ad" class="outline-3">
<h3 id="orga5a88ad"><span class="section-number-3">16.3</span> ITT+UA</h3>
<div class="outline-text-3" id="text-16-3">
<p>
But ITT+UA is <b>not</b> a set theory; not all types are sets! In particular,
\({\cal U}\) is a proper groupoid; there are non-trivial paths between elements.
</p>

<p>
For example, we will show two non-related paths between \(1+1=2\) and
\(2 = 1+1\). We know that
</p>

<p>
\[ UA: (A = B) \simeq (A \simeq B)
\]
</p>

<p>
and we are going to use it to create two different paths.
</p>

<ul class="org-ul">
<li>\(ud(id)\)</li>
<li>\(ud(not)\)</li>
</ul>

<p>
and \(id \neq not : 2 \to 2\) by function extensionality; they are two different
equivalences. We also have \(refl(tt) : tt =_2 tt\); and by transport if the
two paths were the same up to higher homotopy, \(tr('') : ff = tt\), which is 
falsable.
</p>
</div>
</div>

<div id="outline-container-org629b246" class="outline-3">
<h3 id="org629b246"><span class="section-number-3">16.4</span> H-props</h3>
<div class="outline-text-3" id="text-16-4">
<p>
Start with \(n \geq -2\). 
</p>

<div class="definition">
<p>
A type \(A\) is an <b>h-prop</b> or prop iff
</p>

<p>
\[ \mathrm{IsProp(A)} :\equiv
\prod_{x,y:A} Id(x,y)
\]
</p>

</div>

<p>
It is a subsingleton and it has at most one element up to higher
homotopy. The problem with this naming is that this collides with
the idea that propositions are types! It is better to call them
<b>h-props</b> instead of <b>props</b>.
</p>

<p>
The truth of these propositions is proof-irrelevant for types that
are called h-props.
</p>
</div>

<div id="outline-container-org28fd323" class="outline-4">
<h4 id="org28fd323"><span class="section-number-4">16.4.1</span> Example: NuPRL and Markov's principle</h4>
<div class="outline-text-4" id="text-16-4-1">
<p>
In NuPRL, the types were specifications, and proofs where programs.
If we want to look for a zero on a sequence
</p>

<p>
\[s : \left( \sum_{t:Nat\to Nat}\sum_{i:Nat} t(i) = 0 \right)
\to 
\left(\sum_{i : [0..|s|-1]} s(i) = 0\right)
\]
</p>

<p>
but here there is a solution in constant time! The \(i\) is part of the
specification, we provided too much information on the input. The
problem here is proof-relevance. How could we suppress this information
in a type?
</p>

<p>
The first idea is an observation by <b>Brower</b>: we can change the specification
to use double negation
</p>

<p>
\[s : \left(\neg\neg \sum_{t:Nat\to Nat}\sum_{i:Nat} t(i) = 0 \right)
\to 
\left(\sum_{i : [0..|s|-1]} s(i) = 0\right)
\]
</p>

<p>
but now, should a while terminate? <b>Markov's principle</b> says that, if you
can prove that a machine can't fail to halt, then it must halt. This is a
very contentfull statement in a constructivist setting. This is a very
strong axiom, the characteristic of the Russian school of constructivism.
(Markov, Kolmogorov).
</p>
</div>
</div>

<div id="outline-container-org9a3120a" class="outline-4">
<h4 id="org9a3120a"><span class="section-number-4">16.4.2</span> Double negation and computational content</h4>
<div class="outline-text-4" id="text-16-4-2">
<p>
In NuPRL, we do not have Markov's principle. We would change \(Nat \to Nat\) to
\(FinSeq(k)\) in order to have a bound. Double negation kill computational,
proof relevant content.
</p>

<div class="proposition">
<p>
For any \(A\), \(\mathrm{IsProp}(\neg \neg A)\).
</p>

</div>

<p>
It has a simple proof.
</p>
</div>
</div>

<div id="outline-container-orgc4b1b23" class="outline-4">
<h4 id="orgc4b1b23"><span class="section-number-4">16.4.3</span> Gödel's double negation translation</h4>
<div class="outline-text-4" id="text-16-4-3">
<p>
The idea of Gödel was to embed classical into constructive logic.
Here, classical logic is just a particular case of constructive
logic. This is called <i>squashing</i>
</p>

<ul class="org-ul">
<li>\(\|1\| = 1\)</li>
<li>\(\|A \wedge B\| = \|A\| \wedge \|B\|\)</li>
<li>\(\|0\| = 0\)</li>
<li>\(\|A \vee B\| = \neg\neg(\|A\| \vee \|B\|)\)</li>
</ul>

<p>
For implication, we have to choices
</p>

<ul class="org-ul">
<li>if we only want to just squash, \(\|A \supset B\| = \|A\|\supset \|B\|\), suffices.</li>
<li>but if we want to recover classical logic, \(\|A\| \supset (\neg\neg \|B\|)\).</li>
</ul>

<p>
Classical logic is constructive + double negation elimination; the
notion of \(\neg\neg A \supset A\).
</p>

<ul class="org-ul">
<li>with the first option, \(\|\neg\neg A \supset A\| = \neg\neg A \supset A\).</li>
<li>with the second one, \(\|\neg\neg A \supset A\| = \neg\neg A \supset \neg\neg A\), which is true!</li>
</ul>

<p>
This is called the CTS transform for compilers. Where \(\neg A\) is interpreted
as a countinuation for compilers. This is the type of a continuation
</p>

<p>
\[
(\|A\| \times (\|B\| \to 0)) \to 0
\]
</p>

<p>
With this technique, classical logic can be recovered from the constructivistic
logic.
</p>
</div>
</div>
</div>

<div id="outline-container-orga95cbf8" class="outline-3">
<h3 id="orga95cbf8"><span class="section-number-3">16.5</span> Propositional truncation</h3>
<div class="outline-text-3" id="text-16-5">
<p>
We will abstract the idea of squasing into truncation; the idea is
to quotient by the full relation. You take a type and a relation where
you quotient by all the relationships. The notion of subsingleton is
also useful to do proof-irrelevance.
</p>

<p>
The idea of a subquotient does not work well with set theories. In
HoTT we will use the idea of a quotient.
</p>
</div>
</div>

<div id="outline-container-orgecd0bc3" class="outline-3">
<h3 id="orgecd0bc3"><span class="section-number-3">16.6</span> Hedberg's theorem</h3>
<div class="outline-text-3" id="text-16-6">
<p>
A type with decidable equality is a set.
</p>

<p>
If \(\prod_{x,y:A} Id(x,y) \vee \neg Id(x,y)\), then \(isSet(A)\).
</p>
</div>

<div id="outline-container-orgcdc3153" class="outline-4">
<h4 id="orgcdc3153"><span class="section-number-4">16.6.1</span> Corollary</h4>
<div class="outline-text-4" id="text-16-6-1">
<p>
Classical logic destroy the higher-homotopy structure! If you
postulate excluded-middle, everything is now gone.
</p>
</div>
</div>

<div id="outline-container-org86ba648" class="outline-4">
<h4 id="org86ba648"><span class="section-number-4">16.6.2</span> Proof</h4>
<div class="outline-text-4" id="text-16-6-2">
<ol class="org-ol">
<li><p>
Decidable equality implies stable equality.
</p>

<p>
\[
   \neg \neg Id(x,y) \to Id(x,y)
   \]
</p></li>

<li>Stability implies sethood.</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org5661b2f" class="outline-2">
<h2 id="org5661b2f"><span class="section-number-2">17</span> Lecture 17: Hedbergs theorem, truncation</h2>
<div class="outline-text-2" id="text-17">
</div><div id="outline-container-orgc46205c" class="outline-3">
<h3 id="orgc46205c"><span class="section-number-3">17.1</span> Last week</h3>
<div class="outline-text-3" id="text-17-1">
<p>
A type is a set if any two proofs of equality are equal. In other
words, if the equality is a proposition. A proposition is a type such
that any two elements of it are equal.
</p>
</div>
</div>

<div id="outline-container-org04ea161" class="outline-3">
<h3 id="org04ea161"><span class="section-number-3">17.2</span> The negations are propositions</h3>
<div class="outline-text-3" id="text-17-2">
<p>
The negation of any type is a proposition.
</p>
</div>

<div id="outline-container-orgb5e3f31" class="outline-4">
<h4 id="orgb5e3f31"><span class="section-number-4">17.2.1</span> Proof</h4>
<div class="outline-text-4" id="text-17-2-1">
<p>
If \(x,y : A \to \bot\), then \(x = y\), as we have function extensionality;
and given any \(a : A\), we could use ex falso quodlibet, \(\mathtt{abort}(xa) : xa = ya\).
</p>
</div>
</div>
</div>

<div id="outline-container-orgb521199" class="outline-3">
<h3 id="orgb521199"><span class="section-number-3">17.3</span> Hedberg's theorem</h3>
<div class="outline-text-3" id="text-17-3">
<p>
A type with decidable equality is a set. Decidable equality
can be written as
</p>

<p>
\[
\prod_{x,y : A} Id(x,y) \vee \neg Id(x,y)
\]
</p>

<p>
and a type is a set if
</p>

<p>
\[
\prod_{x,y: A} \prod_{p,q : x=y} p = q.
\]
</p>
</div>

<div id="outline-container-org4694071" class="outline-4">
<h4 id="org4694071"><span class="section-number-4">17.3.1</span> Proof 1: Decidable equality implies Stable equality</h4>
<div class="outline-text-4" id="text-17-3-1">
<p>
Stable equality, by definition, is
</p>

<p>
\[
\prod_{x,y : A} \neg \neg Id(x,y) \to Id(x,y).
\]
</p>

<p>
In general, what we know is that if \(A \vee \neg A\), then \(\neg\neg A \to A\). This
is only an instance of that.
</p>
</div>
</div>

<div id="outline-container-org1da9740" class="outline-4">
<h4 id="org1da9740"><span class="section-number-4">17.3.2</span> Proof 2: Stable equality implies Sethood</h4>
<div class="outline-text-4" id="text-17-3-2">
<p>
Suppose that the equality on \(A\) is stable, \(h :\prod_{x,y: A} \neg \neg (x = y) \to (x = y)\).
It suffices to show that every \(p : x = x\) is \(p = \mathtt{refl}\). We can apply the
path to get, by transport
</p>

<p>
\[
p_{\ast}(h(x)(x)) =_{\neg\neg x = x \to x = x} h(x)(x)
\]
</p>

<p>
so we know that, for any \(r: \neg\neg (x = x)\), we know that
</p>

<p>
\[
p_{\ast}(h(x)(x)) (r) =_{x = x} h(x)(x)(r).
\]
</p>

<p>
And Lemma 2.9.6 from HoTT book is a technical result, saying that
</p>

<p>
\[
h(x)(x)(r)(p) = h(x)(x)(p_\ast r)= p_{\ast}(h(x)(x)) (r) =_{x = x} h(x)(x)(r) = h(x)(x)(r),
\]
</p>

<p>
where we use that negated types are propositions.
</p>
</div>
</div>

<div id="outline-container-orge37a54f" class="outline-4">
<h4 id="orge37a54f"><span class="section-number-4">17.3.3</span> Example: N is a set</h4>
<div class="outline-text-4" id="text-17-3-3">
<p>
By double induction, we can show the decidability of equality on this
type.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc10f57e" class="outline-3">
<h3 id="orgc10f57e"><span class="section-number-3">17.4</span> Every proposition is a set</h3>
<div class="outline-text-3" id="text-17-4">
<p>
In general, we will get that any n-type is a n+1-type. If
\(\prod_{x,y : A} x = y\), then \(\prod_{x,y:A}\prod_{p,q:x=y} p = q\). Suppose a function given
with \(f : \prod_{x,y:A} x = y\); then we can fix \(x_0:A\) and let \(g(y) \equiv f(x_0)(y)\).
</p>

<p>
By functioriality, if we have \(p : y = y'\), then \(apd(p) : p_{\ast}(g(y)) = g(y')\).
And if \(q : y = y'\) and \(q = g(y^{-1})g(y')\), so \(p = q\).
</p>
</div>
</div>

<div id="outline-container-org26a5800" class="outline-3">
<h3 id="org26a5800"><span class="section-number-3">17.5</span> The statement of anything being a proposition or a set is a proposition</h3>
<div class="outline-text-3" id="text-17-5">
<ul class="org-ul">
<li>\(isProp(isProp(A))\)</li>
<li>\(isProp(isSet(A))\)</li>
</ul>

<p>
In the book, there is a chapter on when is a proposition an equivalence of
two types. \(isProp(isEquiv(A)(B))\)? In the case of the definition by quasiinverses,
it is not a proposition. A function can has many quasiinverses.
</p>
</div>

<div id="outline-container-org9d9a043" class="outline-4">
<h4 id="org9d9a043"><span class="section-number-4">17.5.1</span> First proof</h4>
<div class="outline-text-4" id="text-17-5-1">
<p>
Given \(f,g : isProp(A)\), we will show that they are equal. It suffices to show that
\(x,y:A \vdash - : f(x)(y) =_{x=y} g(x)(y)\). Since \(isProp(A)\) implies \(isSet(A)\), the desired
equation holds.
</p>
</div>
</div>

<div id="outline-container-org7d97dd7" class="outline-4">
<h4 id="org7d97dd7"><span class="section-number-4">17.5.2</span> Second proof</h4>
<div class="outline-text-4" id="text-17-5-2">
<p>
We can use a similar argument.
</p>
</div>
</div>
</div>
<div id="outline-container-orgfd99f03" class="outline-3">
<h3 id="orgfd99f03"><span class="section-number-3">17.6</span> Propositional truncation, aka "squashing"</h3>
<div class="outline-text-3" id="text-17-6">
<p>
When we worked in the Godel double negation translation,
</p>

<p>
\[
\|A \to B\| = \|A\| \to \neg\neg \|B\|
\]
</p>

<p>
A more abstract notion of truncation is do the squashing and not to
worry about recovering classical logic. What you do is to introduce
the type \(\|A\|_{-1}\) of a truncation of \(A\). It has the introduction form
</p>

\begin{prooftree}
\RightLabel{($\|\cdot\|$-I)}
\AxiomC{$M:A$}
\UnaryInfC{$|M| : \|A\|$}
\end{prooftree}

<p>
and the rule that any two elements are going to be the same up to higher
homotopies
</p>

\begin{prooftree}
\AxiomC{$M:A$}
\AxiomC{$N:A$}
\BinaryInfC{$- : Id_{\|A\|}(|M|,|N|)$}
\end{prooftree}

<p>
This is the quotient of \(A\) by the full relation. The elimination form has
to be, then
</p>

\begin{prooftree}
\RightLabel{$\|\cdot\|$ - E}
\AxiomC{$M : \|A\|$}
\AxiomC{$x : A \vdash N : B$}
\AxiomC{$p : isProp(B)$}
\TrinaryInfC{$\mathtt{trunc}(M, x.N, p):B$}
\end{prooftree}

<p>
the requirement of \(B\) to be a proposition, ensures that N's behaviour is
independent of the choice of representative of the suplied equivalence
class. We could relax the condition to a weaker one requiring only this.
</p>
</div>
</div>
<div id="outline-container-orgd6e6319" class="outline-3">
<h3 id="orgd6e6319"><span class="section-number-3">17.7</span> Contractibility</h3>
<div class="outline-text-3" id="text-17-7">
<p>
A type is contractible if it has an element and every other element is
equal to it
</p>

<p>
\[
isContr(A) = \sum_{x:A}\prod_{y:A} x=y
\]
</p>
</div>

<div id="outline-container-orgda6cc0f" class="outline-4">
<h4 id="orgda6cc0f"><span class="section-number-4">17.7.1</span> Lemma</h4>
<div class="outline-text-4" id="text-17-7-1">
<p>
\[
isProp(A) \iff
\prod_{x,y:A} isContr(x=y)
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org9d2e8b7" class="outline-3">
<h3 id="org9d2e8b7"><span class="section-number-3">17.8</span> n-types</h3>
<div class="outline-text-3" id="text-17-8">
<p>
Something is a -2type iff it is contractible. And something is an
n+1-type iff for all \(x,y\), \(x=y\) is a n-type.
</p>

<ul class="org-ul">
<li>A proposition is a -1 type</li>
<li>A set is a 0 type</li>
<li>A groupoid is a type</li>
<li>A 2-groupoid is a 2-type</li>
<li>and so on</li>
</ul>

<p>
Any n-type is also an n+1-type. It is a <b>cumulative hierarchy</b>.
</p>
</div>
</div>

<div id="outline-container-org4b7ec10" class="outline-3">
<h3 id="org4b7ec10"><span class="section-number-3">17.9</span> Not any type is an n-type</h3>
<div class="outline-text-3" id="text-17-9">
<p>
Not any type is an n-type for some n! There are types with a higher structure
up to infinity.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcf0ad47" class="outline-2">
<h2 id="orgcf0ad47"><span class="section-number-2">18</span> Lecture 18: Homotopy n-types, contractability</h2>
<div class="outline-text-2" id="text-18">
</div><div id="outline-container-org11de1f7" class="outline-3">
<h3 id="org11de1f7"><span class="section-number-3">18.1</span> Last week</h3>
<div class="outline-text-3" id="text-18-1">
<p>
We defined contractability using centers of contraction.
It expresses the idea of unique existence \(\exists!\). It is sometimes
written as \(\Sigma!\).
</p>

<p>
Something is contractible if it is a proposition and it has
one element.
</p>
</div>
</div>

<div id="outline-container-org013f004" class="outline-3">
<h3 id="org013f004"><span class="section-number-3">18.2</span> Fact of contractability</h3>
<div class="outline-text-3" id="text-18-2">
<p>
If you fix any point \(a : A\); you can consider the neighborhood of \(A\)
and we can consider the star of \(A\) and that is contractible.
We can prove that
</p>

<p>
\[
isContr\left(\sum_{x:A} a = x\right)
\]
</p>

<p>
given \(a : A\).
</p>
</div>
</div>
<div id="outline-container-org8b93b16" class="outline-3">
<h3 id="org8b93b16"><span class="section-number-3">18.3</span> The special case of the propositional truncation</h3>
<div class="outline-text-3" id="text-18-3">
<p>
We are going to call propositional truncation as -1-truncation.
We can write it as \(\|A\|_{-1}\). It will be useful to define other
truncations. The idea is to have
</p>

<p>
\[
isProp(\|A\|)
\]
</p>

<p>
for any \(A : {\cal U}\). That is to say that the equality type of this type
is contractible as
</p>

<p>
\[
\prod_{x,y:\|A\|} isContr(x = y).
\]
</p>

<p>
The intuition is that
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : A$}
\UnaryInfC{$\Gamma \vdash |M| : \|A\| $}
\end{prooftree}

<p>
and in the elimination rule, we should prevent proofs for depending on
the witness of the inhabitation.
</p>

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma, x : \|A\|, y: \|A\| \vdash \mathtt{squash}(x,y) : x = y$}
\end{prooftree}

<p>
The eliminator was defined as
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : \|A\|$}
\AxiomC{$\Gamma, x : A\vdash N : B$}
\AxiomC{$\Gamma \vdash p : isProp(B)$}
\TrinaryInfC{$\Gamma \vdash elim[B](M,x.N,p) : B$}
\end{prooftree}

<p>
by using that \(B\) was a proposition, we were sure that the result did not
depend on the representative of \(A\).
</p>
</div>
</div>

<div id="outline-container-org9a82d73" class="outline-3">
<h3 id="org9a82d73"><span class="section-number-3">18.4</span> Gentzen and squash</h3>
<div class="outline-text-3" id="text-18-4">
<p>
Squash is another case of a new primitive equality. By Gentzen's principle,
we would need a beta and an eta rule
</p>

<ul class="org-ul">
<li>\(elim[B](|M|; x.N, p) \equiv [M/x]N : B\)</li>
</ul>

<p>
we would like to have a rule such as
</p>

<ul class="org-ul">
<li>\(ap(\lambda z. elim[B](z;x.N,p))(squash(|M|,|N|)) \equiv (|M| =|N|)\)</li>
</ul>

<p>
this is problematic. (?) If you are using a \(J\) and the argument is a
squash, what should that be definitionally equal to?
</p>
</div>
</div>
<div id="outline-container-orgd5f7a48" class="outline-3">
<h3 id="orgd5f7a48"><span class="section-number-3">18.5</span> Revisit the axiom of choice</h3>
<div class="outline-text-3" id="text-18-5">
<p>
The Axiom of Choice \(AC_{\infty}\) has a formulation as
</p>

<p>
\[
\prod_{A : {\cal U}}
\prod_{B : A \to {\cal U}}
\prod_{C : \prod_{x:A} B \to {\cal U}}
\left(
\prod_{x:A}\sum_{y:B_x} C(x,y)
\overset{\simeq}\longrightarrow
\sum_{f : \prod_{x:A} B} \prod_{x:A} C(x,f(x))
\right)
\]
</p>

<p>
and we can check in fact that this is a definable <b>equivalence</b>. It is
not an axiom! it is a theorem. The theorem of choice. We use crucially
the proof relevance to prove it.
</p>
</div>

<div id="outline-container-orgfb4a62e" class="outline-4">
<h4 id="orgfb4a62e"><span class="section-number-4">18.5.1</span> Proof</h4>
<div class="outline-text-4" id="text-18-5-1">
<p>
From left to right
</p>

<p>
\[
\lambda F. \left(
 \lambda x. \mathtt{fst}(F x),
 \lambda x. \mathtt{snd}(F x)
\right)
\]
</p>

<p>
and from right to left
</p>

<p>
\[
\lambda \left\langle f,g\right\rangle . \lambda x .(f x, gx)
\]
</p>

<p>
and those are mutually inverses. We will need eta rules for products and
eta rules for sums.
</p>
</div>
</div>
<div id="outline-container-org25f41e9" class="outline-4">
<h4 id="org25f41e9"><span class="section-number-4">18.5.2</span> It is a theorem</h4>
<div class="outline-text-4" id="text-18-5-2">
<p>
It is not saying exactly what the axixom of choice says usually.
</p>
</div>
</div>
</div>
<div id="outline-container-orgb97fe3d" class="outline-3">
<h3 id="orgb97fe3d"><span class="section-number-3">18.6</span> Versions of the axiom of choice</h3>
<div class="outline-text-3" id="text-18-6">
<p>
If we use propositional truncations we get the actual axiom of choice,
that we will call \(AC_{-1}\).
</p>

\begin{aligned}
AC_{-1} : 
  \prod_{A :{\cal U}} isSet(A) \to 
  \prod_{B : A \to {\cal U}} \prod_{x : A} isSet(B(x)) \to
  \prod_{C : \prod_{x:A} B \to {\cal U}} \prod_{x:A} \prod_{y:B} isProp(C(x,y)) \to \\
  \left(
    \left( \prod_{x:A} \| \sum_{y:B} C(x,y) \| \right) \to
    \left\| \sum_{f : \prod_{x:A} B} \prod_{x:A} C(x,f(x)) \right\|
  \right)
\end{aligned}

<p>
And this is <b>not</b> a theorem. We are using truncation and this is expressing the idea
that there is no functional dependency but we can, nevertheless, build a function.
</p>
</div>

<div id="outline-container-org38b7f46" class="outline-4">
<h4 id="org38b7f46"><span class="section-number-4">18.6.1</span> NuPRL</h4>
<div class="outline-text-4" id="text-18-6-1">
<p>
Using squashing, we can express this also on the NuPRL system.
</p>
</div>
</div>
<div id="outline-container-orgab513a5" class="outline-4">
<h4 id="orgab513a5"><span class="section-number-4">18.6.2</span> Expressivity</h4>
<div class="outline-text-4" id="text-18-6-2">
<p>
The constructive setting is more expressive than the classical one. We can choose,
by introducing identifications, to work on the classical setting.
</p>
</div>
</div>
<div id="outline-container-orgd3d382e" class="outline-4">
<h4 id="orgd3d382e"><span class="section-number-4">18.6.3</span> Restatement</h4>
<div class="outline-text-4" id="text-18-6-3">
<p>
If we use the equivalence from before, we can write that
</p>

<p>
\[
\left\| \sum_{f : \prod_{x:A} B} \prod_{x:A} C(x,f(x)) \right\| \simeq
\left\| \prod_{x:A}\sum_{y:B} C(x,y)  \right\|
\]
</p>

<p>
and that means that we can restate the axiom of choice using
</p>

<p>
\[
    \left( \prod_{x:A} \left\| \sum_{y:B} C(x,y) \right\| \right) \to
    \left\| \prod_{x : A} \sum_{y:B} C(x,y) \right\|
\]
</p>

<p>
instead. And we can reduce this to a simpler form as
</p>

<p>
\[
\prod_{x:X}\|Y(x)\| \to
\left\| \prod_{x:A} Y(x)  \right\|
\]
</p>

<p>
which can be read as "the product of a family of inhabited sets
is an inhabited set". This is also an equivalence.
</p>

<p>
This version of the axiom of choice is false if \(X\) is not constrained
to be a set.
</p>
</div>
</div>
</div>
<div id="outline-container-orgfe5e6fd" class="outline-3">
<h3 id="orgfe5e6fd"><span class="section-number-3">18.7</span> Quasiinverses</h3>
<div class="outline-text-3" id="text-18-7">
<p>
Recall that a quasiinverse was
</p>

<p>
\[ \mathtt{qinv}( f : A \to B) :\equiv
  \sum_{g : B\to A} f \circ g \sim id \times g \circ f \sim id
\]
</p>

<p>
in the presence of function extensionality, we can replace \(\sim\) with
\(=\). We will show that \(qinv\) is not necessarily a -1-type (a proposition).
</p>
</div>

<div id="outline-container-orgb0cd527" class="outline-4">
<h4 id="orgb0cd527"><span class="section-number-4">18.7.1</span> Characterization of quasiinverses</h4>
<div class="outline-text-4" id="text-18-7-1">
<p>
If \(f : A \to B\) and \(e : qinv(f)\) then 
</p>

<p>
\[
qinv(f) \simeq \prod_{x:A} x = x
\]
</p>

<p>
sometimes we write \(x =_{A} x \equiv \Omega(A,x)\). This uses univalence.
</p>
</div>
</div>

<div id="outline-container-org684d655" class="outline-4">
<h4 id="org684d655"><span class="section-number-4">18.7.2</span> Existence of a not-proposition</h4>
<div class="outline-text-4" id="text-18-7-2">
<p>
There is a type \(X\) such that
</p>

<p>
\[
\prod_{x : X} x=_Xx
\]
</p>

<p>
is not a proposition. An example of this is \(X = \pi(\mathbb{S}) \simeq \mathbb{Z}\), which
will be a set. Another one is \(X = K(G,1)\), a space with its fundamental
group being \(G\).
</p>

<p>
As a corollary, \(qinv(f)\) need not be a proposition.
</p>
</div>
</div>
</div>

<div id="outline-container-org2512396" class="outline-3">
<h3 id="org2512396"><span class="section-number-3">18.8</span> A good definition of equivalence</h3>
<div class="outline-text-3" id="text-18-8">
<p>
The criterion is that it should be a proposition, so the quasiinverses
definition does not qualify. We create new definitions
</p>

<ul class="org-ul">
<li>\(isContr(f)\)</li>
<li>\(isBiequiv(f)\), we have a left inverse and a right inverse.</li>
<li>\(isHalfAdjoint(f)\), defined by quasiinverses plus a coherence condition.</li>
</ul>

<p>
all these definitions are equivalent. And these are all propositions.
</p>
</div>
</div>

<div id="outline-container-org09f1041" class="outline-3">
<h3 id="org09f1041"><span class="section-number-3">18.9</span> Contractability definition of equivalence</h3>
<div class="outline-text-3" id="text-18-9">
<p>
For \(f : A \to B\),
</p>

<p>
\[
isContr(f) :\equiv
\prod_{y:B} isContr(fibers_f(y))
\]
</p>

<p>
where
</p>

<p>
\[
fibers_f(y) \equiv \sum_{x:A} f(x) = y
\]
</p>

<p>
the things that are sent by \(f\) to \(y\). The total "sum of fibers" is
the total \(A\).
</p>
</div>

<div id="outline-container-orge67e142" class="outline-4">
<h4 id="orge67e142"><span class="section-number-4">18.9.1</span> Voevodsky's definition of equivalence</h4>
<div class="outline-text-4" id="text-18-9-1">
<p>
The definition can be stated as that exists a unique
</p>

<p>
\[
\prod_{y:B}\sum_{z: fib_f(y)} \prod_{z' : fib_f(y)} z = z'
\]
</p>

<p>
so the function is a bijection up to homotopy.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org177f39b" class="outline-2">
<h2 id="org177f39b"><span class="section-number-2">19</span> Lecture 19: Inductive types I</h2>
<div class="outline-text-2" id="text-19">
</div><div id="outline-container-orgd1a948a" class="outline-3">
<h3 id="orgd1a948a"><span class="section-number-3">19.1</span> Last week</h3>
<div class="outline-text-3" id="text-19-1">
<p>
We suppose that we had a quasiinverse for \(f\) given by an inverse,
and two proofs of the inverse, \(\left\langle g_0,\alpha_0,\beta_0 \right\rangle\). The claim was that
</p>

<p>
\[
qinv(f) \simeq \prod_{x:A} x = x
\]
</p>

<p>
in the presence of FUNEXT, this is equivalent to the fact that
\(id = id\). The type of quasiinverses is
</p>

<p>
\[
\sum_{g : B \to A}\sum_{\alpha : g \circ f = id} \sum_{\beta : f \circ g = id} 1
\]
</p>

<p>
and a similar type is contractible
</p>

<p>
\[
\sum_{g : B \to A} \sum_{\beta : f \circ g = id} 1
\]
</p>

<p>
with center \((g_0,\beta_0)\). This says that \(f\) has exactly one right inverse.
If we consider \((g_1,b_1) : \sum_{g : B \to A}\sum_{\beta : f \circ g = id} 1\), we have to show that
\(p : g_1 = g_0\) and then, by transport \(- : \beta_0 = \beta_1\).
</p>
</div>
</div>
<div id="outline-container-org3da26b9" class="outline-3">
<h3 id="org3da26b9"><span class="section-number-3">19.2</span> Biinverse</h3>
<div class="outline-text-3" id="text-19-2">
<p>
If we use the definition of biinverses
</p>

<p>
\[
binv(f) :\equiv
\left(\sum_{r : B \to A} f \circ r = id\right) \times
\left( \sum_{l:B \to A} l \circ f = id \right)
\]
</p>

<p>
as both factors are contractible, the type is contractible. This
definition is related to the half-adjoint definition. \(f\) is
bijective up to homotopy if this holds.
</p>

<p>
It is reasonable to speak of \(biinv(f)\) true as it were a proposition.
</p>
</div>
</div>
<div id="outline-container-org8318004" class="outline-3">
<h3 id="org8318004"><span class="section-number-3">19.3</span> Inductive types (the nat case)</h3>
<div class="outline-text-3" id="text-19-3">
<p>
Reconsider Nat in simple types. We had introductory rules
</p>

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash 0 : Nat$}
\AxiomC{$\Gamma \vdash M : Nat$}
\UnaryInfC{$\Gamma \vdash succ(M) : Nat$}
\noLine
\BinaryInfC{}
\end{prooftree}

<p>
elimination rules
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M : Nat$}
\AxiomC{$\Gamma \vdash M_{0} : A$}
\AxiomC{$\Gamma, x:A \vdash M_1 : A$}
\TrinaryInfC{$\Gamma \vdash rec[A](M,M_0,x.M_1) : A$}
\end{prooftree}

<p>
with beta-like rules (inversion principle), which can be
expressed as a commutative diagram
</p>

<ul class="org-ul">
<li>\(rec[A](0,M_0; x.M_1) \equiv M_0\)</li>
<li>\(rec[A](succ(M);M_0,x.M_1) \equiv [rec[A](M,M_0,x.M_1)/x]M_0 : A\)</li>
</ul>

<p>
and an eta-like rule (unicity principle), which is the
unicity of the diagram
</p>

\begin{prooftree}
\AxiomC{$[0/x]N \equiv M_{0}$}
\AxiomC{$z : Nat \vdash [succ(z)/x]N \equiv [[z/x]N/x]M_{1}:A$}
\BinaryInfC{$\Gamma, x:Nat \vdash N \equiv rec[A](x,M_0,x.M_1)$}
\end{prooftree}
</div>
</div>
<div id="outline-container-org9917e8d" class="outline-3">
<h3 id="org9917e8d"><span class="section-number-3">19.4</span> Local definition</h3>
<div class="outline-text-3" id="text-19-4">
<p>
We could write the introductions as
</p>

<ul class="org-ul">
<li>\(\vdash 0 : Nat\)</li>
<li>\(x : Nat \vdash succ(x) : Nat\)</li>
</ul>

<p>
and the global version works on a suitable theory. We could write
them even as
</p>

<ul class="org-ul">
<li>\(0 : 1 \to Nat\)</li>
<li>\(succ : Nat \to Nat\)</li>
</ul>

<p>
and in a suitable theory, we can derive the rules from the constants.
Note that those two notations are NOT the same thing!
</p>

<p>
We could write also the induction as an element of a function type
</p>

\begin{prooftree}
\AxiomC{$\Gamma \vdash M_{0} : A$}
\AxiomC{$\Gamma, x:A \vdash M_1 : A$}
\BinaryInfC{$\Gamma, z:Nat \vdash rec[A](M_0, x.M_1)(z) : A$}
\end{prooftree}
</div>
</div>
<div id="outline-container-orge81ca87" class="outline-3">
<h3 id="orge81ca87"><span class="section-number-3">19.5</span> Nat-algebras</h3>
<div class="outline-text-3" id="text-19-5">
<p>
We can write this as a single function
</p>

<p>
\[
z : 1 + Nat \vdash case\{-.0 ; x.succ(x)\}(z) : Nat
\]
</p>

<p>
we can write this as
</p>

<p>
\[
z : 1 + Nat \vdash \{0,succ\}(z) : Nat
\]
</p>

<p>
This notation uses eta/beta properties of coproducts and
products to get its etea/beta properties. Any mapping
\(\alpha : 1 + Nat \to Nat\) is called a <b>Nat-algebra</b>. More generally,
a Nat-algebra is \(\alpha : 1 + A \to A\). 
</p>

<p>
A <b>Nat-algebra category</b> is defined by the idea that if we have
two Nat-algebras, we can define a mapping between them as
</p>

<p>
\[\begin{tikzcd}
1+A\dar{\alpha}\rar{1+h} & 1+B\dar{\beta} \\
A\rar{h} & B
\end{tikzcd}\]
</p>

<p>
and we call this a Nat-homomorphism. The previous definition of the
naturals is in fact the initial object in the category on
nat-homomorphisms. This is an initial algebra, there is a unique
morphism from this algebra to all the others; and this morphism is
precisely the recursor. Any other morphism is unique up to higher
homotopy to the other morphism (eta-rule).
</p>

<p>
There are implicit uses of the Yoneda Lemma here.
</p>
</div>
</div>
<div id="outline-container-org0ecf2ee" class="outline-3">
<h3 id="org0ecf2ee"><span class="section-number-3">19.6</span> F-algebra</h3>
<div class="outline-text-3" id="text-19-6">
<p>
Given a functor \(F\) on some category, we are going to define a
F-algebra. The particular case of Nat is \(F(X) = 1 + X\).
</p>

<p>
\[\begin{tikzcd}
F(A)\dar{\alpha}\rar{F(h)} & F(B)\dar{\beta} \\
A\rar{h} & B
\end{tikzcd}\]
</p>
</div>
</div>

<div id="outline-container-org6b141d4" class="outline-3">
<h3 id="org6b141d4"><span class="section-number-3">19.7</span> F-coalgebra</h3>
<div class="outline-text-3" id="text-19-7">
<p>
We can define coalgebras and study the final objects on coalgebra
categories. The unique function to a final coalgebra is a corecursor.
</p>
</div>

<div id="outline-container-org8399d12" class="outline-4">
<h4 id="org8399d12"><span class="section-number-4">19.7.1</span> Exercise</h4>
<div class="outline-text-4" id="text-19-7-1">
<p>
What is the final coalgebra for Nat? \(F(X) = 1+X\).
</p>
</div>
</div>
</div>

<div id="outline-container-org529fce8" class="outline-3">
<h3 id="org529fce8"><span class="section-number-3">19.8</span> Lambek's lemma</h3>
<div class="outline-text-3" id="text-19-8">
<p>
If \(i : F(I) \to I\) is an initial F-algebra, then \(i\) is an
isomorphism; and then, \(F(I) \cong I\).
</p>

<p>
This is called a <b>fixed point</b>.
</p>
</div>

<div id="outline-container-org0c96601" class="outline-4">
<h4 id="org0c96601"><span class="section-number-4">19.8.1</span> Proof</h4>
<div class="outline-text-4" id="text-19-8-1">
<p>
If we have an algebra, we also have \(FI\) as an algebra
</p>

<p>
\[\begin{tikzcd}
FI  \rar[dashed]{F!}\dar{i} & FFI \dar{Fi} \\
I  \rar[dashed]{!} & FI
\end{tikzcd}\]
</p>

<p>
we use that the first one is initial. And we also have
</p>

<p>
\[\begin{tikzcd}
FI \rar{i}\dar[dashed]{F!}\ar[dd,bend right,swap,"Id"] & 
I \dar[dashed]{!}\ar[dd,bend left,"Id"] \\
FFI  \rar{Fi}\dar{Fi} & FI \dar{i} \\
FI  \rar{i} & FI
\end{tikzcd}\]
</p>

<p>
so we know that \(i \circ ! = id\) and \(!\circ i = F(i \circ !) = id\).
</p>
</div>
</div>
<div id="outline-container-orgea16a71" class="outline-4">
<h4 id="orgea16a71"><span class="section-number-4">19.8.2</span> CoLambek</h4>
<div class="outline-text-4" id="text-19-8-2">
<p>
If we have a final coalgebra it is also an isomorphism.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org4ecd075" class="outline-2">
<h2 id="org4ecd075"><span class="section-number-2">20</span> Lecture 20: Inductive types II</h2>
<div class="outline-text-2" id="text-20">
</div><div id="outline-container-org4fc8637" class="outline-3">
<h3 id="org4fc8637"><span class="section-number-3">20.1</span> Last week</h3>
<div class="outline-text-3" id="text-20-1">
<p>
We reexamined Nat as an inductive type. We claim that \(1+Nat \to Nat\)
is initial in the category of Nat-algebras. Any other Nat-algebra can
be written as \(\alpha = \left\langle \alpha_0,\alpha_{1} \right\rangle\); and the function from the initial algebra
is simply the recursor \(rec[A](\alpha_0,x.\alpha_1)\).
</p>
</div>
</div>

<div id="outline-container-org08fd6c7" class="outline-3">
<h3 id="org08fd6c7"><span class="section-number-3">20.2</span> Nats Inside type theory</h3>
<div class="outline-text-3" id="text-20-2">
<p>
A Nat-algebra would be
</p>

<p>
\[
NatAlg :\equiv
  \sum_{A : {\cal U}} 1+A \to A \simeq
  \sum_{A : {\cal U}} A \times (A \to A)
\]
</p>

<p>
and a Nat-homomorphism is
</p>

<p>
\[
NatHom(\alpha,\beta) :\equiv
  \sum_{h : A \to B} \beta \circ (1+h) = h \circ \alpha
\]
</p>

<p>
then \(\nu :\equiv \left\langle Nat, \{0,succ\} \right\rangle\) is a Nat-algebra an we can prove that this is
in fact initial, which is to say that
</p>

<p>
\[
NatHom(\nu,\alpha) \text{ is contractible}
\]
</p>

<p>
Two terminologically different traditions collide here, so we are using
them both.
</p>
</div>
</div>
<div id="outline-container-org51c0116" class="outline-3">
<h3 id="org51c0116"><span class="section-number-3">20.3</span> Derivation of mathematical induction</h3>
<div class="outline-text-3" id="text-20-3">
<p>
The recursor for the naturals is
</p>

\begin{prooftree}
\AxiomC{$M_{0}:A$}
\AxiomC{$x.A \vdash M_1:A$}
\BinaryInfC{$x:Nat \vdash rec[A](M_0;x.M_1) : A$}
\end{prooftree}

<p>
with its beta and eta rules. In HoTT, we take the eta rules
to be not definitional equalities \(\equiv\) but propositional equalities \(=\).
</p>
</div>
</div>

<div id="outline-container-org57b9164" class="outline-3">
<h3 id="org57b9164"><span class="section-number-3">20.4</span> The principle of induction</h3>
<div class="outline-text-3" id="text-20-4">
<p>
The induction principle says that, given,
</p>

<ul class="org-ul">
<li>\(x : Nat \vdash P(x) : {\cal U}\)</li>
<li>\(M_0 : P(0)\)</li>
<li>\(x:Nat, y:P(x) \vdash M_1 : P(succ(x))\)</li>
</ul>

<p>
we have
</p>

<ul class="org-ul">
<li>\(z:Nat \vdash ind[x.P](M_0,x.y.M_1)(z) : P(z)\)</li>
</ul>

<p>
and the beta and eta rules are similar to those of the recursor.
But, with respect to what equality?
</p>
</div>
</div>
<div id="outline-container-orgece9402" class="outline-3">
<h3 id="orgece9402"><span class="section-number-3">20.5</span> Idea</h3>
<div class="outline-text-3" id="text-20-5">
<p>
Consider \(\int P :\equiv \sum_{x:Nat} P(x)\), we define an auxiliary function
</p>

<ul class="org-ul">
<li>\(i :\equiv \lambda z:Nat.\  rec[\int P](\left\langle 0,M_0 \right\rangle; \left\langle x,y \right\rangle.\left\langle succ(x), M_1 \right\rangle)(z)\)</li>
<li>\(i0 \equiv \left\langle 0,M_0 \right\rangle\)</li>
<li>\(i(succ(M)) \equiv \left\langle succ(fst(M)), [snd(iM)/y]M_1 \right\rangle\)</li>
</ul>
</div>

<div id="outline-container-org08593d1" class="outline-4">
<h4 id="org08593d1"><span class="section-number-4">20.5.1</span> Kleene discovered how to define the predecessor</h4>
</div>
</div>

<div id="outline-container-org95d46ed" class="outline-3">
<h3 id="org95d46ed"><span class="section-number-3">20.6</span> Lambek inside type theory</h3>
<div class="outline-text-3" id="text-20-6">
<p>
We can define functors up to higher homotopy. When we apply Lambek, we
get a fixed point \(FI \cong I\) up to isomorphism.
</p>
</div>

<div id="outline-container-orga057dca" class="outline-4">
<h4 id="orga057dca"><span class="section-number-4">20.6.1</span> Not functors</h4>
<div class="outline-text-4" id="text-20-6-1">
<p>
There are cases where, if we define things like \(F X =X \to X\), we get a 
<b>non-algebraic</b> datatype. There is a way of solving this equations using
fixpoint induction.
</p>
</div>
</div>

<div id="outline-container-orged39e97" class="outline-4">
<h4 id="orged39e97"><span class="section-number-4">20.6.2</span> Nat+</h4>
<div class="outline-text-4" id="text-20-6-2">
<p>
We could define a final coalgebra as
</p>

<p>
\[
Nat^+ \to 1 + Nat^{+}
\]
</p>

<p>
and we could think of this loosely as \(Nat \cup \{\infty\}\).
</p>
</div>
</div>
</div>

<div id="outline-container-org6f3feb9" class="outline-3">
<h3 id="org6f3feb9"><span class="section-number-3">20.7</span> Positive and negative types</h3>
<div class="outline-text-3" id="text-20-7">
<p>
Positive types correspond to inductive types and negative types
correspond to coinductive types. Negative types are limits, and
positive types are colimits.
</p>
</div>
</div>
<div id="outline-container-orgc4156eb" class="outline-3">
<h3 id="orgc4156eb"><span class="section-number-3">20.8</span> Brower ordinals (aka W types)</h3>
<div class="outline-text-3" id="text-20-8">
<p>
Well-founded trees or preorders. The ordinals codify what transfinite
induction is.
</p>
</div>

<div id="outline-container-org102f771" class="outline-4">
<h4 id="org102f771"><span class="section-number-4">20.8.1</span> Brower ordinals</h4>
<div class="outline-text-4" id="text-20-8-1">
<p>
Nodes labeled as
</p>

<ul class="org-ul">
<li>\(0\)                   z</li>

<li>\(1 = sup(0)\)          s -&gt; z</li>

<li>\(2 = sup(1)\)          s -&gt; s -&gt; z</li>

<li>&#x2026;</li>

<li>\(\omega = sup(0,1\dots)\)     w -&gt; z
&#x00ad;&gt; s -&gt; z
 &#x00ad;&gt; s -&gt; s -&gt; z
  &#x00ad;&gt; &#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-org1adaa26" class="outline-4">
<h4 id="org1adaa26"><span class="section-number-4">20.8.2</span> Well-founded</h4>
<div class="outline-text-4" id="text-20-8-2">
<p>
There is no infinite descendent branches, there may be as many width
branches as we want.
</p>

<p>
The right definition is that "The principle of transfinite induction is
valid". Is something holds for all predecessors.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc4a3d38" class="outline-3">
<h3 id="orgc4a3d38"><span class="section-number-3">20.9</span> Formation rule for W-types</h3>
<div class="outline-text-3" id="text-20-9">
<p>
Given a type of node sorts, \(A\), 
</p>

\begin{prooftree}
\AxiomC{$A:{\cal U}$}
\AxiomC{$x:A \vdash B:{\cal U}$}
\BinaryInfC{$W_{x:A}B : {\cal U}$}
\end{prooftree}

<p>
given \(x:A \vdash B(x)\) is the branching factor; the index type for
the predecessors. 
</p>
</div>

<div id="outline-container-org017352d" class="outline-4">
<h4 id="org017352d"><span class="section-number-4">20.9.1</span> Example</h4>
<div class="outline-text-4" id="text-20-9-1">
<p>
As an example, \(A :\equiv 1+1 = [Z,S]\) is an enumeration type, and
you define \(B\) by case analysis.
</p>

<ul class="org-ul">
<li>\(B(Z) :\equiv \bot : {\cal U}\)</li>
<li>\(B(S) :\equiv 1 : {\cal U}\)</li>
</ul>

<p>
and \(Nat\) will be \(W_{x:A}B\).
</p>
</div>
</div>
</div>

<div id="outline-container-org88e3375" class="outline-3">
<h3 id="org88e3375"><span class="section-number-3">20.10</span> Introduction rule for W-types</h3>
<div class="outline-text-3" id="text-20-10">
\begin{prooftree}
\AxiomC{$a:A$}
\AxiomC{$x:B(a) \vdash w(x) : W_{x:A}$}
\BinaryInfC{$sup[a](x.w) : W_{x:A}B$}
\end{prooftree}
</div>

<div id="outline-container-org8eec6f6" class="outline-4">
<h4 id="org8eec6f6"><span class="section-number-4">20.10.1</span> Example</h4>
<div class="outline-text-4" id="text-20-10-1">
<ul class="org-ul">
<li>\(0 :\equiv sup[z](x.abort(x))\)</li>
<li>\(1 :\equiv sup[s](-.0)\)</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgee311b2" class="outline-3">
<h3 id="orgee311b2"><span class="section-number-3">20.11</span> Elimination rule, non-dependent form</h3>
<div class="outline-text-3" id="text-20-11">
\begin{prooftree}
\AxiomC{$\Gamma,\ a:A,\ p:B(a) \to W_{x:A}B,\ r:B(a) \to C \vdash M:C$}
\UnaryInfC{$z: W_{x:A}B \vdash  wrec[c](  a,p,r.M     )(z)      :C$}
\end{prooftree}

<p>
and we are going to have a beta rule
</p>

<ul class="org-ul">
<li>\(wrec[c]( a,p,r.M )(sup[a](w)) \equiv [a,w,\lambda z. wrec[c](a,p,r.M) /a,p,r] M\)</li>
</ul>

<p>
and the eta rule says that it is the only such thing.
</p>
</div>

<div id="outline-container-org3540970" class="outline-4">
<h4 id="org3540970"><span class="section-number-4">20.11.1</span> Polynomial functors</h4>
<div class="outline-text-4" id="text-20-11-1">
<p>
The W types determine polynomial functors over certain classes.
</p>

<p>
\[
F(x) :\equiv \sum_{a:A}B(a) \to X
\]
</p>

<p>
in the case of naturals, it is \((1\to X)\times (X\to X)\).
</p>
</div>
</div>
</div>

<div id="outline-container-orga8ba898" class="outline-3">
<h3 id="orga8ba898"><span class="section-number-3">20.12</span> Transfinite induction - dependent elimination rule</h3>
<div class="outline-text-3" id="text-20-12">
\begin{prooftree}
\AxiomC{$\Gamma,z: W_{x:A} B \vdash P:{\cal U}$}
\noLine\UnaryInfC{$\Gamma,a:A, p:B(a) \to W_{x:A}B, h:\prod_{b:B(a)}P(p(b)) \vdash M : P(sup[a](p))$}
\UnaryInfC{$\Gamma,z:W_{x:A}B \vdash wind[x.P](  ): P(z)$}
\end{prooftree}
</div>
</div>

<div id="outline-container-orgd710cd3" class="outline-3">
<h3 id="orgd710cd3"><span class="section-number-3">20.13</span> Exercise: Invent the M type, dual to the W type</h3>
</div>
</div>
<div id="outline-container-org4f04bb2" class="outline-2">
<h2 id="org4f04bb2"><span class="section-number-2">21</span> Lecture 21: Higher inductive types I</h2>
<div class="outline-text-2" id="text-21">
</div><div id="outline-container-org583a702" class="outline-3">
<h3 id="org583a702"><span class="section-number-3">21.1</span> Last week: lower inductive types</h3>
<div class="outline-text-3" id="text-21-1">
<p>
Well-founded trees \(W_{x:A} B\) with an elimination rule based on
transfinite induction. It can be characterized as the homotopy
initial algebras for polynomial functors.
</p>

<p>
The universal property is here propositional.
</p>
</div>
</div>

<div id="outline-container-org54c0bb8" class="outline-3">
<h3 id="org54c0bb8"><span class="section-number-3">21.2</span> Higher inductive types</h3>
<div class="outline-text-3" id="text-21-2">
<p>
The idea is to take some type of free structure using inductive
definitions with equational laws. It is a similar idea to the
presentation of algebraic structures using generatos and relations.
This will be a 0-type concept; but higher inductive types must be
more general than that.
</p>

<p>
They are relevant because of
</p>

<ol class="org-ol">
<li>full higher-dimensional structure or path structure.</li>
<li>proof-relevance means generators and relations are the same thing.</li>
</ol>

<p>
Informally, we are building the free infinity groupoid on the structure
we are building.
</p>
</div>
</div>

<div id="outline-container-org9a77520" class="outline-3">
<h3 id="org9a77520"><span class="section-number-3">21.3</span> Current status of HoTT</h3>
<div class="outline-text-3" id="text-21-3">
<p>
HoTT is ITT + UA + HIT. The Univalence Axiom is a matter of mathematical
efficiency; and the HIT is a matter of expressiveness on higher types.
</p>

<p>
HITs are not yet fully worked out.
</p>
</div>
</div>
<div id="outline-container-org47464d6" class="outline-3">
<h3 id="org47464d6"><span class="section-number-3">21.4</span> Example: interval</h3>
<div class="outline-text-3" id="text-21-4">
<p>
We can write the interval using inductive definitions
</p>

<ul class="org-ul">
<li>\(0 : I\), a 0-cell.</li>
<li>\(1 : I\), a 0 cell.</li>
<li>\(seg : Id_I(0,1)\), a 1-cell.</li>
</ul>

<p>
This definition implies the existence of other paths. For example,
\(seg^{-1} : Id(1,0)\) or \(refl(0) : Id(0,0)\). Moreover, they are significant
and they induce even higher paths.
</p>

<p>
It is an open problem what is implied for a given inductive
definition.
</p>
</div>
</div>

<div id="outline-container-orgc428b4e" class="outline-3">
<h3 id="orgc428b4e"><span class="section-number-3">21.5</span> Recursor</h3>
<div class="outline-text-3" id="text-21-5">
<p>
An inductive definition induces a recursor; a function from an
initial object on a given category.
</p>

<p>
In the example, given any "interval algebra", we have a function
from the interval to it
</p>

\begin{prooftree}
\AxiomC{$a:A$}
\AxiomC{$b:B$}
\AxiomC{$\beta : a=_Ab$}
\TrinaryInfC{$z:I \vdash rec[A](a,b,\beta)(z):A$}
\end{prooftree}

<p>
the Gentzen's inversion principle holds as
</p>

<ul class="org-ul">
<li>\(rec[A](a,b,\beta)(0) \equiv a : A\)</li>
<li>\(rec[A](a,b,\beta)(1) \equiv b : A\)</li>
<li>\(ap_{rec[A](a,b,\beta)}(seg) = \beta : a =_{A} b\)</li>
</ul>

<p>
we could think of the first two cases as an \(ap\) on 0-types. Note that
the third case uses a propositional equality; \(ap\) is a defined
function! we cannot define what its behaviour should be.
</p>
</div>
</div>
<div id="outline-container-orge2bfb81" class="outline-3">
<h3 id="orge2bfb81"><span class="section-number-3">21.6</span> Induction</h3>
<div class="outline-text-3" id="text-21-6">
<p>
The induction can be written as
</p>

\begin{prooftree}
\AxiomC{$z: I \vdash A(z) : {\cal U}$}
\AxiomC{$a_0 : A(0)$}
\noLine\UnaryInfC{$a_1 : A(1)$}
\noLine\UnaryInfC{$p : a_0 =_{seg}^{z.A} a_1$}
\BinaryInfC{$z:I \vdash ind[z.A](a_0,a_1,p) : A(z)$}
\end{prooftree}

<p>
where we are using a transportation to have that
</p>

<p>
\[
trans[z.A](seg)(a_0) =_{A(1)} a_1
\]
</p>

<p>
And now we expect the following equations to hold
</p>

<ul class="org-ul">
<li>\(ind[z.A](a_0,a_1,p)(0) \equiv a_0 : A(0)\)</li>
<li>\(ind[z.A](a_0,a_1,p)(1) \equiv a_1 : A(1)\)</li>
<li>\(ap_{ind[z.A](a_0,a_1,p)}(seg) = p\) true.</li>
</ul>

<p>
and there is also a unicity condition
</p>
</div>
</div>
<div id="outline-container-org069e450" class="outline-3">
<h3 id="org069e450"><span class="section-number-3">21.7</span> Example: circle</h3>
<div class="outline-text-3" id="text-21-7">
<p>
The circle \(\mathbb{S}^1\) is a type given by the higher inductive definition
</p>

<ul class="org-ul">
<li>\(base : \mathbb{S}^{1}\), a 0-cell</li>
<li>\(loop : Id(base,base)\), a 1-cell</li>
</ul>

<p>
This definition induces loops such as \(loop \cdot loop : Id(base,base)\) or
\(loop^{-1} : Id(base,base)\). Those will form the integers; a set-level
group.
</p>
</div>

<div id="outline-container-org0217bb1" class="outline-4">
<h4 id="org0217bb1"><span class="section-number-4">21.7.1</span> Recursor</h4>
<div class="outline-text-4" id="text-21-7-1">
<p>
It is defined as
</p>

\begin{prooftree}
\AxiomC{$a_0 : A$}
\AxiomC{$l : a_0 =_A a_0$}
\BinaryInfC{$z : \mathbb{S}^1 \vdash rec[A](a_0,l)(z) : A$}
\end{prooftree}

<p>
where
</p>

<ul class="org-ul">
<li>\(rec[A](a_0,l)(base) \equiv a_0 : A\)</li>
<li>\(ap_{rec[A](a_0,l)}(loop) = l\) true</li>
</ul>

<p>
and we can have the unicity
</p>

<ul class="org-ul">
<li>\(z : \mathbb{S}^1\vdash P : {\cal U}\)</li>
<li>\(b : P(base)\)</li>
<li>\(l : b =^{z.P}_{loop} b\), so this is preserved going around the loop</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9d579c7" class="outline-3">
<h3 id="org9d579c7"><span class="section-number-3">21.8</span> Recall: the interval</h3>
<div class="outline-text-3" id="text-21-8">
<p>
The interval characterizes the total path space of \(A\)
</p>

<p>
\[
I \to A \simeq
\int Id_A :\equiv \sum_{x,y:A} Id(x,y)
\]
</p>

<p>
the identifications are paths. The usual way to do this in Topology is
similar. Here,
</p>

<p>
\[ \mathbb{S}^{1} \to A \simeq
\int \Omega_A := \sum_{x:A}Id(x,x)
\]
</p>

<p>
is the loop space.
</p>

<ol class="org-ol">
<li>define \(f : (\mathbb{S}^1 \to A) \to \int \Omega_A\) by \(\lambda g. \left\langle g(base), ap_g(loop) \right\rangle\).</li>
<li>we show that \(\prod_{l : \int \Omega_A} fib(l)\) is contractible</li>
</ol>
</div>
</div>

<div id="outline-container-orgf2077f5" class="outline-3">
<h3 id="orgf2077f5"><span class="section-number-3">21.9</span> Suspension: circle</h3>
<div class="outline-text-3" id="text-21-9">
<p>
Another picture of \(\mathbb{S}^1\) could use two poles and two
meridians. This is called \(Susp(2)\).
</p>

<ul class="org-ul">
<li>\(N : \mathbb{S}^1\)</li>
<li>\(S :\ \mathbb{S}^1\)</li>
<li>\(mer : 2 \to (N = S)\)</li>
</ul>

<p>
and we can check that this is equivalent to the previous
definition.
</p>
</div>
</div>

<div id="outline-container-org344fe6a" class="outline-3">
<h3 id="org344fe6a"><span class="section-number-3">21.10</span> Suspensions</h3>
<div class="outline-text-3" id="text-21-10">
<p>
We define \(Susp(A)\) as two zero cells
</p>

<ul class="org-ul">
<li>\(N : Susp(A)\)</li>
<li>\(S : Susp(A)\)</li>
</ul>

<p>
and the meridians
</p>

<ul class="org-ul">
<li>\(mer : A \to (N = S)\)</li>
</ul>
</div>

<div id="outline-container-org7f72ac6" class="outline-4">
<h4 id="org7f72ac6"><span class="section-number-4">21.10.1</span> Example: susp<sup>2</sup> is the sphere</h4>
<div class="outline-text-4" id="text-21-10-1">
<p>
\(Susp^2(2)\) has two meridians associated with N and S and also two
higher-order paths W E associated with the two meridians on
\(Susp(2)\).
</p>

<p>
We will prove that this is the sphere.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc517110" class="outline-3">
<h3 id="orgc517110"><span class="section-number-3">21.11</span> Suspensions in type theory</h3>
<div class="outline-text-3" id="text-21-11">
<p>
We can define the introduction
</p>

\begin{prooftree}
\AxiomC{$x:A\vdash m(x) : n =_{B} s$}
\AxiomC{$n:B$}
\noLine\UnaryInfC{$s:B$}
\BinaryInfC{$z:Susp(A) \vdash rec[B](n,s,x.m):B$}
\end{prooftree}

<p>
with the beta and eta usual rules.
</p>
</div>
</div>
</div>
<div id="outline-container-org7d38b99" class="outline-2">
<h2 id="org7d38b99"><span class="section-number-2">22</span> Lecture 22: Higher inductive types II</h2>
<div class="outline-text-2" id="text-22">
</div><div id="outline-container-orge1217c9" class="outline-3">
<h3 id="orge1217c9"><span class="section-number-3">22.1</span> Last week</h3>
<div class="outline-text-3" id="text-22-1">
<p>
We defined suspensions
</p>

<ul class="org-ul">
<li>\(N : Susp(A)\)</li>
<li>\(S : Susp(A)\)</li>
<li>\(merid : \prod_{x:A} N =_{Susp(A)} S\)</li>
</ul>

<p>
We defined functorial mappings from the suspension of a type
to another type.
</p>
</div>
</div>

<div id="outline-container-org89e219a" class="outline-3">
<h3 id="org89e219a"><span class="section-number-3">22.2</span> Iterated suspension</h3>
<div class="outline-text-3" id="text-22-2">
<p>
It can be showed that
</p>

<p>
\(\mathbb{S}^1 \simeq Susp(2)\)
</p>

<p>
by defining an invertible function between them.
</p>
</div>
</div>

<div id="outline-container-org794a676" class="outline-3">
<h3 id="org794a676"><span class="section-number-3">22.3</span> Pointed types</h3>
<div class="outline-text-3" id="text-22-3">
<p>
A point is preserved up to homotopy by mappings
</p>

<p>
\[
X \multimap Y := \sum_{f:X\to Y} f(x_0) = y_0
\]
</p>
</div>
</div>

<div id="outline-container-org8fc0f98" class="outline-3">
<h3 id="org8fc0f98"><span class="section-number-3">22.4</span> Characterization of suspensions</h3>
<div class="outline-text-3" id="text-22-4">
<p>
Suspensions follow a kind of adjunction with the loop space
</p>

<p>
\[
(Susp(A) \multimap B) \simeq (A \to \Omega(B))
\]
</p>
</div>
</div>

<div id="outline-container-org31bd278" class="outline-3">
<h3 id="org31bd278"><span class="section-number-3">22.5</span> Pushouts</h3>
<div class="outline-text-3" id="text-22-5">
<p>
Generally used for amalgamation properties and quotients. In classical
set theory. They are the dual of pullbacks, the constrained subset of
a product.
</p>

<p>
We glue two sets in a way that a deisgnated subset of the two sets is
regarded as the same; as \(A \sqcup^{C} B\), where \(C\) is the diagram for the 
considered subset. The coproduct is the special case where \(C = \varnothing\).
</p>
</div>

<div id="outline-container-org4f84f83" class="outline-4">
<h4 id="org4f84f83"><span class="section-number-4">22.5.1</span> Denotational semantics</h4>
<div class="outline-text-4" id="text-22-5-1">
<p>
In denotational semantics, we want to form the disjoint union of two
types with common elements.
</p>
</div>
</div>

<div id="outline-container-org1b41b69" class="outline-4">
<h4 id="org1b41b69"><span class="section-number-4">22.5.2</span> In sets</h4>
<div class="outline-text-4" id="text-22-5-2">
<p>
In sets, pushouts do always exist.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf81cc36" class="outline-3">
<h3 id="orgf81cc36"><span class="section-number-3">22.6</span> Pushouts as HIT</h3>
<div class="outline-text-3" id="text-22-6">
<p>
We define the inclusions
</p>

<ul class="org-ul">
<li>\(inl : A \to A \sqcup^C B\)</li>
<li>\(inr : B \to A \sqcup^C B\)</li>
</ul>

<p>
and a glue term
</p>

<ul class="org-ul">
<li>\(glue : \prod_{c:C} inl(f(c)) = inr(g(c))\)</li>
</ul>
</div>

<div id="outline-container-org9be8fe7" class="outline-4">
<h4 id="org9be8fe7"><span class="section-number-4">22.6.1</span> Universal constructions</h4>
<div class="outline-text-4" id="text-22-6-1">
\begin{prooftree}
\AxiomC{$x:A \vdash l:D$}
\noLine\UnaryInfC{$y:B \vdash r:D$}
\AxiomC{$u:C \vdash q: [f(u)/x]l = [g(u)/x]r$}
\BinaryInfC{$z: A \sqcup^C B \vdash rec[D](x.l,y.r;u.q) : D$}
\end{prooftree}

<p>
with the usual beta/eta rules.
</p>
</div>
</div>

<div id="outline-container-orgbb9d94d" class="outline-4">
<h4 id="orgbb9d94d"><span class="section-number-4">22.6.2</span> Suspension</h4>
<div class="outline-text-4" id="text-22-6-2">
<p>
In particular,
</p>

<p>
\(Susp(A) := 1 \sqcup^{A} 1\)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgae5a039" class="outline-2">
<h2 id="orgae5a039"><span class="section-number-2">23</span> Lecture 23: Pushouts</h2>
<div class="outline-text-2" id="text-23">
</div><div id="outline-container-org38a18cd" class="outline-3">
<h3 id="org38a18cd"><span class="section-number-3">23.1</span> Last week</h3>
<div class="outline-text-3" id="text-23-1">
<p>
Pushouts as HITs.
</p>
</div>
</div>

<div id="outline-container-org6c85ba6" class="outline-3">
<h3 id="org6c85ba6"><span class="section-number-3">23.2</span> Quotients as HITs</h3>
<div class="outline-text-3" id="text-23-2">
<p>
We can define the expected quotients
</p>

<ul class="org-ul">
<li>\(a:A \vdash q(a) : A/R\)</li>
<li>\(a,b:A, r:R(a,b) \vdash wd(a,b,r) : q(a) = q(b)\)</li>
</ul>

<p>
and a truncation rule
</p>

<ul class="org-ul">
<li>\(x,y:A/R, p,q:x=y \vdash tr(x,y,p,q):p=q\)</li>
</ul>

<p>
so that \(A/R\) is a set.
</p>
</div>

<div id="outline-container-orgb95b66d" class="outline-4">
<h4 id="orgb95b66d"><span class="section-number-4">23.2.1</span> Example: Integers as formal differences of naturals</h4>
</div>
</div>

<div id="outline-container-org88dd8b4" class="outline-3">
<h3 id="org88dd8b4"><span class="section-number-3">23.3</span> Truncations as HITs</h3>
<div class="outline-text-3" id="text-23-3">
<p>
The propositional truncation \(\|A\|_{-1}\) can be defined as a type
with an induction principle.
</p>
</div>

<div id="outline-container-orgc9f7eba" class="outline-4">
<h4 id="orgc9f7eba"><span class="section-number-4">23.3.1</span> Induction on integers</h4>
</div>
</div>

<div id="outline-container-org2200702" class="outline-3">
<h3 id="org2200702"><span class="section-number-3">23.4</span> Fundamental group of S1</h3>
<div class="outline-text-3" id="text-23-4">
<p>
\[
\pi_1(\mathbb{S}^1) \simeq \mathbb{Z}
\]
</p>

<p>
we can show that \(\Omega(\mathbb{S}^1,base) \simeq \mathbb{Z}\).
</p>
</div>

<div id="outline-container-org204196b" class="outline-4">
<h4 id="org204196b"><span class="section-number-4">23.4.1</span> Proof</h4>
<div class="outline-text-4" id="text-23-4-1">
<p>
In the proof, we define the winding function from the loop
space to the integers. We then use induction on \(\mathbb{Z}\).
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org17d60f3" class="outline-2">
<h2 id="org17d60f3"><span class="section-number-2">24</span> Exercises</h2>
<div class="outline-text-2" id="text-24">
</div><div id="outline-container-org59541d2" class="outline-3">
<h3 id="org59541d2"><span class="section-number-3">24.1</span> Homework 1: Heyting algebra and IPL <code>[5/6]</code></h3>
<div class="outline-text-3" id="text-24-1">
</div><div id="outline-container-orgc88a7d5" class="outline-4">
<h4 id="orgc88a7d5"><span class="section-number-4">24.1.1</span> <span class="done DONE">DONE</span> Task 1</h4>
<div class="outline-text-4" id="text-24-1-1">
<div class="statement">
<p>
Show that \(A \wedge (B \vee C) \leq (A \wedge B) \vee (A \wedge C)\) in any Heyting algebra.
Hint: use the Yoneda Lemma.
</p>

</div>

<p>
The Yoneda Lemma in this setting says that the statement is equivalent
to say that, for all \(D\), if \((A \wedge B) \vee (A \wedge C) \leq D\), then \(A \wedge (B \vee C) \leq D\).
In this case we have
</p>

<ul class="org-ul">
<li>\(A \wedge B \leq D\)</li>
<li>\(A \wedge C \leq D\)</li>
</ul>

<p>
and crucially using the definition of exponential
</p>

<ul class="org-ul">
<li>\(B \wedge C \leq B,C \leq A \supset D\).</li>
</ul>
</div>
</div>

<div id="outline-container-org24c6e2a" class="outline-4">
<h4 id="org24c6e2a"><span class="section-number-4">24.1.2</span> <span class="done DONE">DONE</span> Task 2</h4>
<div class="outline-text-4" id="text-24-1-2">
<div class="statement">
<p>
Show that in any Heyting algebra, \(A \supset \bot\) is one of the largest elements
inconsistent with \(A\), and is equivalent to any largest inconsistent one.
</p>

</div>

<p>
By definition, \(A \wedge (A \supset \bot) \leq \bot\), and for any other element \(C\) such that
\(A \wedge C \leq \bot\), \(C \leq (A \supset \bot)\). Any other largest inconsistent element should
satisfy \((A \supset \bot) \leq C\).
</p>
</div>
</div>

<div id="outline-container-org4adb3f5" class="outline-4">
<h4 id="org4adb3f5"><span class="section-number-4">24.1.3</span> <span class="done DONE">DONE</span> Task 3</h4>
<div class="outline-text-4" id="text-24-1-3">
<div class="statement">
<p>
Show that, in any Boolean algebra (complemented distributive lattice),
\(\overline{A} \vee B\) is a valid implementation of \(A \supset B\). That is, it satisfies all
properties of \(A \supset B\).
</p>

</div>

<p>
We know that
</p>

<p>
\[
A \wedge (\overline{A}\vee B) \leq 
(A \wedge \overline{A}) \vee (A \wedge B) \leq
(A \wedge B) \leq B
\]
</p>

<p>
and if \(A \wedge C \leq B\), then
</p>

<p>
\[
C \leq
C \wedge (A \vee \overline{A}) \leq
B \vee (C \wedge \overline{A}) \leq \overline{A} \vee B.
\]
</p>
</div>
</div>
<div id="outline-container-orgb4b7a8e" class="outline-4">
<h4 id="orgb4b7a8e"><span class="section-number-4">24.1.4</span> <span class="todo TODO">TODO</span> Task 4</h4>
<div class="outline-text-4" id="text-24-1-4">
<div class="statement">
<p>
Show that IPL is transitive, which is to say &#x2026;
</p>

</div>
</div>
</div>

<div id="outline-container-org0c46be6" class="outline-4">
<h4 id="org0c46be6"><span class="section-number-4">24.1.5</span> <span class="done DONE">DONE</span> Task 5</h4>
<div class="outline-text-4" id="text-24-1-5">
<div class="statement">
<p>
Show that for any Heyting algebra and any evaluation function on
atoms, if \(\Gamma \vdash P\) true then \(\Gamma^+\leq P^{\ast}\). You only have to consider the
cases in which the last rule applied is \((\supset I)\) or \((\supset E)\).
</p>

</div>

<ul class="org-ul">
<li>In the first case, \((\supset I)\), we know that \(\Gamma, A \vdash B\). By induction,
we know that \(\Gamma^{+} \wedge A^{\ast} \leq B^{\ast}\), and then \(\Gamma^{ +} \leq (A^{\ast} \supset B^{\ast})\).</li>
<li>In the second case, we know by induction that \(\Gamma^{ +} \leq A^{\ast} \supset B^{\ast}\) and
\(\Gamma^{+} \leq A^{\ast}\), so \(\Gamma^{ +} \leq A^{\ast} \wedge (A^{\ast} \supset B^{\ast}) \leq B^{\ast}\).</li>
</ul>
</div>
</div>

<div id="outline-container-orga24e500" class="outline-4">
<h4 id="orga24e500"><span class="section-number-4">24.1.6</span> <span class="done DONE">DONE</span> Task 6</h4>
<div class="outline-text-4" id="text-24-1-6">
<div class="statement">
<p>
Consider the Lindembaum algebra of IPL where the elements are all
propositions in IPL (with the translation \((-)^{\ast}\) being the identity function) 
and the relationship \(\leq\) is defined by provability in IPL. That is, \(A\leq B\) 
iff \(A \text{ true} \vdash B\text{ true}\). Show that this is a Heyting algebra. You only have to
prove the transitivity. You may assume weakening and exchange of IPL,
or cite previous tasks as lemmas.
</p>

</div>

<p>
If \(A \leq B\) and \(B \leq C\), we know that, by weakening, \(A \text{ true},B \text{ true} \vdash C \text{ true}\).
We now can apply transitivity to \(A \text{ true} \vdash B \text{ true}\) and the previous formula
to obtain \(A \text{ true} \vdash C \text{ true}\).
</p>
</div>
</div>
</div>
<div id="outline-container-org634f278" class="outline-3">
<h3 id="org634f278"><span class="section-number-3">24.2</span> Homework 2: Kindom of Kittens <code>[0/7]</code></h3>
<div class="outline-text-3" id="text-24-2">
</div><div id="outline-container-orgc2781ad" class="outline-4">
<h4 id="orgc2781ad"><span class="section-number-4">24.2.1</span> <span class="todo TODO">TODO</span> Task 1</h4>
<div class="outline-text-4" id="text-24-2-1">
<div class="statement">
<p>
Weite down a suitable morphism in terms of the primitive constructs and
the morphisms immediately available in each subtask. The primitive
constructs include \(\mathrm{id}\), \(f \circ g\), \(\left\langle f,g \right\rangle\), \(\mathtt{fst}\), \(\mathtt{snd}\), \(\mathtt{inl}\), \(\mathtt{inr}\), \(\left\{ f,g \right\}\), \(\lambda(f)\) and \(\mathtt{map}\).
</p>

<ul class="org-ul">
<li><b>Reflexivity</b>, write down a morphism from \(\Gamma^+ \times P^{\ast}\) to \(P^{\ast}\).</li>
<li><b>Contraction</b>, write down a morphism from \(\Gamma^{ +} \times P^{\ast}\) to \(Q^{\ast}\) in terms of
a morphism \(f \colon (\Gamma^{ +}\times P^{\ast})\times P^{\ast} \to Q^{\ast}\).</li>
<li><b>Weakening</b>, write down a morphism from \(\Gamma^{ +} \times P^{\ast}\) to \(Q^{\ast}\) in terms of a
morphism \(f \colon \Gamma^{ +} \to Q^{\ast}\).</li>
<li><b>Exchange</b>, write down a morphism from \((\Gamma^{ +}\times Q^{\ast}) \times P^{\ast}\) to \(R^{\ast}\) in terms
of a morphism \(f \colon (\Gamma^{ +}\times P^{\ast}) \times Q^{\ast} \to R^{\ast}\).</li>
<li><b>Substitution</b>, write down a morphism from \(\Gamma^{ +}\) to \(Q^{\ast}\) in terms of two 
morphisms \(f \colon \Gamma^{ +}\to P^{\ast}\) and \(g\colon \Gamma^{ +}\times P^{\ast} \to Q^{\ast}\).</li>
</ul>

</div>
</div>
</div>

<div id="outline-container-orgd7bcb18" class="outline-4">
<h4 id="orgd7bcb18"><span class="section-number-4">24.2.2</span> <span class="todo TODO">TODO</span> Task 2</h4>
</div>
<div id="outline-container-org4c40be0" class="outline-4">
<h4 id="org4c40be0"><span class="section-number-4">24.2.3</span> <span class="todo TODO">TODO</span> Task 3</h4>
</div>
<div id="outline-container-orgf4acc1e" class="outline-4">
<h4 id="orgf4acc1e"><span class="section-number-4">24.2.4</span> <span class="todo TODO">TODO</span> Bonus Task 1</h4>
</div>
<div id="outline-container-orgd6866b5" class="outline-4">
<h4 id="orgd6866b5"><span class="section-number-4">24.2.5</span> <span class="todo TODO">TODO</span> Task 4</h4>
</div>
<div id="outline-container-orgde9a15f" class="outline-4">
<h4 id="orgde9a15f"><span class="section-number-4">24.2.6</span> <span class="todo TODO">TODO</span> Task 5</h4>
</div>
<div id="outline-container-org434248d" class="outline-4">
<h4 id="org434248d"><span class="section-number-4">24.2.7</span> <span class="todo TODO">TODO</span> Task</h4>
</div>
</div>
</div>
<div id="outline-container-orgb0de7de" class="outline-2">
<h2 id="orgb0de7de"><span class="section-number-2">25</span> Bibliography</h2>
<div class="outline-text-2" id="text-25">
<ul class="org-ul">
<li>Awodey, Category theory.</li>
<li>Programming in Martin-Löf Type theory.</li>
<li>Homotopy Type Theory book.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Mario Román</p>
<p class="date">Created: 2017-12-03 Sun 11:58</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
