#+TITLE: UniMath
# Notebook

#+latex_header: \usepackage{tikz-cd}

* Spartan type theory - Andrej Bauer
* Univalent foundations - Martin Escardo
* Semantics for type theory - Helfer
# Notes on paper.

** Formal languages and semantics
Traditional definition of formal languages. An alphabet and rules to
inductively construct words. We call $L$ the set of valid strings.

*** Example: boolean algebra
 * symbols $\Sigma = \left\{ p_1,\dots,p_n, \wedge,\neg,\implies,(,),\top,\bot,\dots \right\}$ 
   atomic propositions and logical symbols.
 * valid strings are defined inductively as
   * singletons $p_i$, $\top$ or $\bot$
   * connectors: if $a, b$ are valid, so are $a \wedge b, a \vee b, \neg a, \dots$

*** Semantics
The semantics assigns to each string a number $0$ or $1$,

\[
s \colon L \to \left\{ 0,1 \right\}
\]

and this evaluation will depend on the evaluation of atomic propositions.
If we call $\Omega = \left\{ p_1,\dots,p_n \right\}$, it depends on a valuation $v \colon \Omega \to \left\{ 0,1 \right\}$.
Connectives are interpreted naturally.

*** Observation
Sometimes $s_v(a) = s_v(b)$ regardless of $v$; in particular, $s_v(a) = 1$ regardless
of $v$ for some formulae (tautologies and absurds).

\[
s_v(A \wedge B) = s_v(B \wedge A)
\]

** Simply typed lambda calculus
*** Definition
Taking a inductively defined set of types

 * given type $I$
 * function types $\alpha \to \beta$

The set $\Sigma$ of symbols has countably many variables of each type and the symbols of
lambda calculus $(,),\lambda, O,+,r$. We call a pair $<s,\alpha>$ a typed string; the set of
valid strings is our set of valid strings; we write $s : \alpha$ instead of $<s,\alpha> \in L$.

We have

 * $0 : I$
 * $^+ \colon I \to I$
 * $r \colon I \to (I \to I) \to I \to I$

and the usual typing rules for application and abstraction

 * if $s : \alpha, l : \alpha \to \beta$ then $sl : \beta$,
 * if $s : \beta$ and $x$ var of type $\beta$, $\lambda x.s \colon \alpha \to \beta$.

*** Semantics
We associate a set to each type, with $M(I) := \mathbb{N}$ and $M(\alpha \to \beta) := M(\beta)^{M(\alpha)}$;
and to each constant a correspondant element on the set, for example,
$M(r)$ is the unique function defined by induction.

Based on this, we construct an interpretation for each lambda term with
$M(s) \in M(\alpha)$. We give first an interpretation of variables $v = (v_{\alpha})_{\alpha \in Tp}$.
Application is interpreted as application of functions and abstraction
is interpreted as the interpretation of the body of the lambda under
a valuation that takes the bounded variable to the argument.

We can define a set of free variables of a string. Note that an
interpretation $M_{v}(x)$ with a valuation $v$ only depends on the
values of $v$ for the elements of $FV(x)$.

*** Observations
We have alpha-equivalence, beta-reduction and eta-reduction
inside the interpretation.

** Semantics of MLTT
*** Set-theoretical semantics
It is more difficult to write a complete formalization of mltt.

We want to interpret $x_1:A_1,\dots,x_n:A_n \vdash A\ \mathrm{type}$ after interpreting

$A_1,\dots,A_n$ as sets. The interpretation will be a tuple
\[
a = \left\langle a_1,\dots,a_n \right\rangle
\]
where $a_i \in M(A_i)$, this is called the *realization of the context*.

To create an element $x_1:A_1,\dots,x_n:A_n \vdash t : A$ we should get
$M_v(t) \in M_v(A)$. We want an interpretation such that for every
definitional equality $A \equiv B$, we have the same sets $M_v(A) = M_v(B)$.

\[
M(s = t) = \left\{ \ast \right\} \mbox{ if } M(s)=M(t) \mbox{, and } \varnothing \mbox{ otherwise}
\]

But these semantics satisfy UIP.
*** Topological semantics
We interpret each type as a topological space; and each function type
as the set of continuous functions. We use simplicial sets in MLTT.

UIP does not hold under this interpretation.
* Set-level mathematics - Helfer
** Motivation
Given $X$ topological space, we say it is n-truncated if

\[
\pi_m(X) = 0 \text{ for all } m > n.
\]

 1) We know from homotopy theory that if $X$ is n-truncated, the
    space of paths between any two points is (n-1)-truncated.

 2) If $X$ is 0-truncated, it is homotopy equivalent to a discrete
    space; that is, a set.

A similar phenomenon occurs in category theory; a category has
objects, morphisms between them, morphisms between morphisms and so
on. The connection between categories and homotopical spaces is known
as the *[[https://ncatlab.org/nlab/show/homotopy+hypothesis][homotopy hypothesis]]*.

There are some definitions of ∞-groupoids for which the homotopy
hypothesis is a proven theorem.

** H-levels
\[
\mathsf{isofhlevel} : \mathbb{N} \to {\cal U} \to {\cal U}
\]

defined as

 * $\mathsf{isoflevel}(0,X) :\equiv \mathsf{iscontr}(X)$
 * $\mathsf{isoflevel}(S(n),X) :\equiv \prod_{x,x' : X} \mathsf{isofhlevel}(n,x=x')$

*** Sets
A set is a type of h-level 2.

 * Dependent pair of sets is a set.
 * Binary product of sets is a set.
 * Dependent function from a set to a family of sets is a set.
 * Function space to a set is a set.

** How to show that something is not a set
*** Decidable types
A type $A$ is *decidable* if $A + \neg A$.

A type $A$ has *decidable path-equality* if all path types are
decidable

\[
\prod_{x,x' : A} (x = x') + \neg (x = x')
\]

*** Hedberg's theorem
Any type with decidable equality is a set.

*** Are all types sets?
 * In spartan type theory, there are types that cannot be shown to be
   sets. It is consistent with spartan type theory to assume that all
   types are sets.
 * In univalent type theory, some types are not sets.

*** Another set

\[
\mathsf{hProp} :\equiv \sum_{X:U} \mathsf{isaprop}(X)
\]

is a set. This can be generalized: the type of types of n-level is
of (n+1)-level.

*** The universe is not a set
The booleans have a non-trivial automorphism.

*** Sets and propositions

\[
\mathsf{isInjective}(f) :\equiv \prod_{x,x' : X}f(x) = f(x') \to x = x'
\]

is a proposition when $X,Y$ as sets.

** Set-level quotient
*** Quotient
A map compatible with a relation is a map from the quotient;
the equivalence is given by precomposition with the projection.

\[
\sum_{f \colon X \to Y} \mathsf{isCompatible}(f) \simeq X/R \to Y
\]

*** Subtype
A subtype of a type is a map from the subtype to hProp.
# Note that this definition is similar to that of the dependent sum.

**** The type of binary relations is a set

*** Defining quotients
Equivalence classes

\[
\mathsf{iseqclass}(A) = \| \mathsf{carrier}(A) \| \times 
\left( \prod_{x,y:A} Rxy \to Ax \to Ay \right)
\times 
\left( \prod_{x,y:A} Ax \to Ay \to Rxy \right)
\]

Quotients

\[
X/R :\equiv \sum_{A : X \to \mathsf{hProp}} \mathsf{iseqclass}(A)
\]

** Set-level mathematics
*** Groups in type theory
We want the proofs of the axioms of a group to be elements of a
proposition; having this, any two groups with the same data are
equivalent.

A group isomorphism is a bijective function compatible with the
group structure; we can show that the type of equality between
of groups is the type of isomorphisms.

# Identity is isomorphism for groups!  Transport along the path given
# by univalence for a equivalence is conjugation by that equivalence.
* Category theory - Lumsdaine
Definition of a category in the univalent setting is different than
that from a classical setting. What works the same in this
formulation and what works differently?

** Difference
*** Definition
A *category* consists of 

 * a type of objects $\mathrm{ob}({\cal C})$;
 * for each pair of objects, a set of morphisms $\mathrm{hom}(a,b)$;

and the axioms, with are all about morphisms and they behave well with
objects not being a set.

**** Terminology
This is terminology in UniMath, in the HoTT book this is called
*precategory*. A precategory here would be just types
$\mathsf{hom}(x,y)$ but this is not discussed in the HoTT book.

**** Set-category
A set category is a category where $\mathrm{ob}({\cal C})$ is a set.

**** Carrier set
It is useful to take the carrier to be a set; in other case, we
would get a more general algebraic structure where equalities do
not work as well as in the particular case.

*** Examples
**** Sets
Sets is a category in the way we expect; but it is *not* a set
category; the set of h-sets is not an h-set. This is why we don't
want to take set-categories as our definition.

**** Simplicial set
$\Delta$ can be constructed with objects $\mathbb{N}$ and maps $m \to n$ 
as order-preserving maps $f \colon [m] \to [n]$. It is a set
category.

Small cats, combinatorially constructed ones, are set-cats in
practice.

*** Univalent categories and Rezk completion
A category is *univalent* if the canonical map (defined with identity)
$x = y \to \mathrm{Iso}(x,y)$ is an equivalence for each pair $x,y$. This is like
an internal version of univalence.

This is called /saturated category/ in the HoTT book.

**** Example: sets
Sets is univalent. Most categories in practice are univalent.
Tops, Grps, and algebraic constructions in general. Products of
univalent categories and algebras for a monad in a univalent
category are univalent.

/Heuristic:/ if the category is "the category of its objects" it will
be univalent.

**** Counterexample
The homotopy category of topological spaces where

 * objects are topological spaces,
 * and maps are continuous maps up to homotopy.

There are non-equal objects here that are homotopically-equal. It is not
the category of topological spaces but a category of homotopy types, and
we are using topological spaces only as representatives.

**** Counterexample
A preorder (category where each hom-set is a prop) is univalent iff
$\mathrm{ob}({\cal C})$ is a set and $x \leq y, y \leq x$ implies $x = y$.

**** Fact: categories have an univalent completion operation
The *Rezk completion* (Ahrens, Kapulkin, Shulman) is a sort of
univalent completion.

\[\begin{tikzcd}
& RC({\cal C}) \drar[dashed] & \\
{\cal C} \ar{rr} \urar & & {\cal E}
\end{tikzcd}\]

Given any univalent ${\cal E}$, any map factors through the completion.
The functor ${\cal C} \to RC({\cal C})$ is fully faithfull and essentially surjective.

** What works the same?
Most things that don't mention equality of objects; modulo being
careful about existence vs chosen structure and not having the
axiom of choice.

*** Example: having products
If they exist, they are unique up to isomorphism.

*** In univalent categories
In an univalent category, they are actually unique! existence
of products is equivalent to chosen products and this is a
proposition.

*** Unimath

- Functors, natural transformations.
- Monads.
- Functor categories.
- Colimits, limits.

** What works a little differently?
*** Displayed categories
Examples of equality on objects

 * *fibrations of categories*; for example, if ${\cal C}$ has pullbacks, the
   arrow category ${\cal C}^{\to}$ with the projection to the second object is a
   fibration.

   Typically, fibers are

   \[
   \mathrm{ob}({\cal E}) :\equiv \sum_{x : {\cal E}} \text{objects of ${\cal E}$ over ${\cal C}$}
   \]

*** Definition of displayed category
A displayed category over ${\cal C}$ has

 - for $c : \mathrm{ob}({\cal C})$, a type $\mathrm{ob}_c({\cal D})$;
 - for 

   \[\begin{tikzcd}
   d' & d \\
   c'\rar{f} & c
   \end{tikzcd}\]
 
   a set $\mathrm{hom}(d',d)$.

They 

*** Utility of displayed categories
Useful for building up categories of multi-component structures and
reasoning about them one cat at a time.

*** Example: groups
Groups are a displayed category over sets. The objects are group
structures over set; and the $\mathrm{hom}(g,g')$ is a function
between the sets together with the assumption that it preserves the
structure.
*** !
** What works very differently?
Unexplored territory

*** 2-categories, higher categories
In univalent categories, we don't have enough strict 2-categories; in
particular, the category Cat is not a strict 2-category in the univalent
setting.
* How to implement type theory in an hour - Andrej Bauer

 * Unicode input
 * Pretty printing
 * Loading filesv
 
** Type checking
Bidirectional type checking.

** Equality of types
Not every theory has an algorithm checking equality of types.

 -> We use an algorithm due to Bob Harper.
    It uses the extensionality rules to check for equality of terms.

     * Every two elements of the unit are equal.
     * We can apply a judgmental eta rule with a fresh variable.

    We have *extensional rules* for free.

It does not work with primitive symbols. Then we switch to normalization
phase and structurally compare the two weak normal form of the types.
* Future of unimath - Ahrens
* Presentations
** Nominal sets
*** First definition
Given a set with decidable equality (eg. naturals), $X$ is
a nominal set...

\[
\forall x \in X, \exists A \subset \mathbb{N}, \forall u \in \mathrm{Perm}(\mathbb{N}), u|_{A} = \mathrm{id}: u(x) = x
\]
*** Presheaf definition
Ĺet $N$ be the subcategory of finite subsets of $\mathbb{N}$,
morphisms injections. A nominal set is a functor $\mathbb{N} \to \mathrm{Set}$.
** 
